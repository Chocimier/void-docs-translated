<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="utf-8">
        <title>Void Linux Handbook</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
        </script>
		<!-- Work around some values being stored in localStorage wrapped in quotes -->
		<script type="text/javascript">
			try {
				var sidebar = localStorage.getItem('mdbook-sidebar');

				if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
					localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
				}
			} catch (e) { }
		</script>

		<header>
			<nav id="void-nav">
				<ul>
					<li><a id="skip-to-content" tabindex="1" href="#main">Skip to content</a></li>
					<li>
						<button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
								<path d="M1 3v2h18V3zm0 8h18V9H1zm0 6h18v-2H1z"/>
							</svg>
						</button>
					</li>
				
					<li>
						<button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
								<path d="M7.5 13c3.04 0 5.5-2.46 5.5-5.5S10.54 2 7.5 2 2 4.46 2 7.5 4.46 13 7.5 13zm4.55.46C10.79 14.43 9.21 15 7.5 15 3.36 15 0 11.64 0 7.5S3.36 0 7.5 0C11.64 0 15 3.36 15 7.5c0 1.71-.57 3.29-1.54 4.55l6.49 6.49-1.41 1.41-6.49-6.49z"/>
							</svg>
						</button>
					</li>
				
                                        <noscript>
                                          <li class="js-unavailable">Search functionality requires JavaScript</li>
                                        </noscript>
				</ul>
				<ul id="nav-right">
					<li><a href="https://www.voidlinux.org">Home</a></li>
					<li><a href="https://www.voidlinux.org/news/">News</a></li>
					<li><a href="https://www.voidlinux.org/download/">Download</a></li>
					<li><a href="https://www.voidlinux.org/packages/">Packages</a></li>
					<li><a href="https://docs.voidlinux.org">Documentation</a></li>
					<li><a href="https://man.voidlinux.org/">Manual Pages</a></li>
					<li><a href="https://reddit.com/r/voidlinux">Forum</a></li>
					<li><a href="https://voidlinux.org/contribute/">Join Us</a></li>
					<li><a href="https://github.com/void-linux">GitHub</a></li>
				</ul>
			</nav>
		</header>

		<div id="content">

			<!-- Hide / unhide sidebar before it is displayed -->
			<script type="text/javascript">
				var html = document.querySelector('html');
				var sidebar = 'hidden';
				if (document.body.clientWidth >= 1080) {
					try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
					sidebar = sidebar || 'visible';
				}
				html.classList.remove('sidebar-visible');
				html.classList.add("sidebar-" + sidebar);
			</script>

			<nav id="sidebar" aria-label="Table of contents">
				<ol class="chapter"><li class="chapter-item expanded "><a href="about/index.html"><strong aria-hidden="true">1.</strong> O Voidzie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/history.html"><strong aria-hidden="true">1.1.</strong> Historia</a></li><li class="chapter-item expanded "><a href="about/about-this-handbook.html"><strong aria-hidden="true">1.2.</strong> O podręczniku</a></li><li class="chapter-item expanded "><a href="about/infradocs.html"><strong aria-hidden="true">1.3.</strong> InfraDocs</a></li></ol></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">2.</strong> Instalacja</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/live-images/index.html"><strong aria-hidden="true">2.1.</strong> Obrazy instalacyjne</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/live-images/prep.html"><strong aria-hidden="true">2.1.1.</strong> Przygotowanie nośnika instalacyjnego</a></li><li class="chapter-item expanded "><a href="installation/live-images/partitions.html"><strong aria-hidden="true">2.1.2.</strong> Partycjonowanie</a></li><li class="chapter-item expanded "><a href="installation/live-images/guide.html"><strong aria-hidden="true">2.1.3.</strong> Instrukcja instalacji</a></li></ol></li><li class="chapter-item expanded "><a href="installation/guides/index.html"><strong aria-hidden="true">2.2.</strong> Zaawansowane aspekty instalacji</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/guides/chroot.html"><strong aria-hidden="true">2.2.1.</strong> Instalacja z użyciem chroot (x86/x86_64)</a></li><li class="chapter-item expanded "><a href="installation/guides/fde.html"><strong aria-hidden="true">2.2.2.</strong> Szyfrowanie dysku</a></li><li class="chapter-item expanded "><a href="installation/guides/arm-devices/index.html"><strong aria-hidden="true">2.2.3.</strong> Urządzenia ARM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/guides/arm-devices/platforms.html"><strong aria-hidden="true">2.2.3.1.</strong> Obsługiwany sprzęt</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="installation/musl.html"><strong aria-hidden="true">2.3.</strong> musl</a></li></ol></li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">3.</strong> Konfiguracja</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/man.html"><strong aria-hidden="true">3.1.</strong> Podręczniki programów</a></li><li class="chapter-item expanded "><a href="config/firmware.html"><strong aria-hidden="true">3.2.</strong> Firmware</a></li><li class="chapter-item expanded "><a href="config/locales.html"><strong aria-hidden="true">3.3.</strong> Polonizacja programów</a></li><li class="chapter-item expanded "><a href="config/users-and-groups.html"><strong aria-hidden="true">3.4.</strong> Użytkownicy i grupy</a></li><li class="chapter-item expanded "><a href="config/services/index.html"><strong aria-hidden="true">3.5.</strong> Demony i usługi- runit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/services/user-services.html"><strong aria-hidden="true">3.5.1.</strong> Usługi zarządzane przez użytkownika</a></li><li class="chapter-item expanded "><a href="config/services/logging.html"><strong aria-hidden="true">3.5.2.</strong> Logowanie</a></li></ol></li><li class="chapter-item expanded "><a href="config/rc-files.html"><strong aria-hidden="true">3.6.</strong> rc.conf, rc.local, rc.shutdown</a></li><li class="chapter-item expanded "><a href="config/cron.html"><strong aria-hidden="true">3.7.</strong> Cron</a></li><li class="chapter-item expanded "><a href="config/ssd.html"><strong aria-hidden="true">3.8.</strong> Dyski SSD</a></li><li class="chapter-item expanded "><a href="config/security/index.html"><strong aria-hidden="true">3.9.</strong> ZAbezpieczenia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/security/apparmor.html"><strong aria-hidden="true">3.9.1.</strong> AppArmor</a></li></ol></li><li class="chapter-item expanded "><a href="config/date-time.html"><strong aria-hidden="true">3.10.</strong> Zegar</a></li><li class="chapter-item expanded "><a href="config/kernel.html"><strong aria-hidden="true">3.11.</strong> Jądro</a></li><li class="chapter-item expanded "><a href="config/power-management.html"><strong aria-hidden="true">3.12.</strong> Zarządzanie energią</a></li><li class="chapter-item expanded "><a href="config/network/index.html"><strong aria-hidden="true">3.13.</strong> Sieci</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/network/firewalls.html"><strong aria-hidden="true">3.13.1.</strong> Zapora sieciowa</a></li><li class="chapter-item expanded "><a href="config/network/wpa_supplicant.html"><strong aria-hidden="true">3.13.2.</strong> wpa_supplicant</a></li><li class="chapter-item expanded "><a href="config/network/iwd.html"><strong aria-hidden="true">3.13.3.</strong> IWD</a></li><li class="chapter-item expanded "><a href="config/network/networkmanager.html"><strong aria-hidden="true">3.13.4.</strong> NetworkManager</a></li><li class="chapter-item expanded "><a href="config/network/connman.html"><strong aria-hidden="true">3.13.5.</strong> ConnMan</a></li></ol></li><li class="chapter-item expanded "><a href="config/network-filesystems.html"><strong aria-hidden="true">3.14.</strong> Sieciowe systemy plików</a></li><li class="chapter-item expanded "><a href="config/session-management.html"><strong aria-hidden="true">3.15.</strong> Zarządzanie stanowiskami</a></li><li class="chapter-item expanded "><a href="config/graphical-session/index.html"><strong aria-hidden="true">3.16.</strong> Środowisko graficzne</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/index.html"><strong aria-hidden="true">3.16.1.</strong> Sterowniki grafiki</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/amd.html"><strong aria-hidden="true">3.16.1.1.</strong> AMD i ATI</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/intel.html"><strong aria-hidden="true">3.16.1.2.</strong> Intel</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/nvidia.html"><strong aria-hidden="true">3.16.1.3.</strong> NVIDIA</a></li><li class="chapter-item expanded "><a href="config/graphical-session/graphics-drivers/optimus.html"><strong aria-hidden="true">3.16.1.4.</strong> NVIDIA Optimus</a></li></ol></li><li class="chapter-item expanded "><a href="config/graphical-session/xorg.html"><strong aria-hidden="true">3.16.2.</strong> Xorg</a></li><li class="chapter-item expanded "><a href="config/graphical-session/wayland.html"><strong aria-hidden="true">3.16.3.</strong> Wayland</a></li><li class="chapter-item expanded "><a href="config/graphical-session/fonts.html"><strong aria-hidden="true">3.16.4.</strong> Kroje pisma</a></li><li class="chapter-item expanded "><a href="config/graphical-session/icons.html"><strong aria-hidden="true">3.16.5.</strong> Ikony</a></li><li class="chapter-item expanded "><a href="config/graphical-session/gnome.html"><strong aria-hidden="true">3.16.6.</strong> GNOME</a></li><li class="chapter-item expanded "><a href="config/graphical-session/kde.html"><strong aria-hidden="true">3.16.7.</strong> KDE</a></li></ol></li><li class="chapter-item expanded "><a href="config/media/index.html"><strong aria-hidden="true">3.17.</strong> Multimedia</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/media/alsa.html"><strong aria-hidden="true">3.17.1.</strong> ALSA</a></li><li class="chapter-item expanded "><a href="config/media/pulseaudio.html"><strong aria-hidden="true">3.17.2.</strong> PulseAudio</a></li><li class="chapter-item expanded "><a href="config/media/sndio.html"><strong aria-hidden="true">3.17.3.</strong> sndio</a></li></ol></li><li class="chapter-item expanded "><a href="config/bluetooth.html"><strong aria-hidden="true">3.18.</strong> Bluetooth</a></li><li class="chapter-item expanded "><a href="config/texlive.html"><strong aria-hidden="true">3.19.</strong> TeX Live</a></li><li class="chapter-item expanded "><a href="config/external-applications.html"><strong aria-hidden="true">3.20.</strong> Programy niedostępne w menadżerze pakietów</a></li><li class="chapter-item expanded "><a href="config/print/index.html"><strong aria-hidden="true">3.21.</strong> Drukowanie</a></li><li class="chapter-item expanded "><a href="config/containers-and-vms/index.html"><strong aria-hidden="true">3.22.</strong> Konterery i maszyny wirtualne</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/containers-and-vms/libvirt.html"><strong aria-hidden="true">3.22.1.</strong> libvirt</a></li><li class="chapter-item expanded "><a href="config/containers-and-vms/lxc.html"><strong aria-hidden="true">3.22.2.</strong> LXC</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="xbps/index.html"><strong aria-hidden="true">4.</strong> Menadżer pakietów XBPS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/advanced-usage.html"><strong aria-hidden="true">4.1.</strong> Zaawansowane tematy</a></li><li class="chapter-item expanded "><a href="xbps/repositories/index.html"><strong aria-hidden="true">4.2.</strong> Repozytoria</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/index.html"><strong aria-hidden="true">4.2.1.</strong> Serwery lustrzane</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/changing.html"><strong aria-hidden="true">4.2.1.1.</strong> Wybów serwera</a></li><li class="chapter-item expanded "><a href="xbps/repositories/mirrors/tor.html"><strong aria-hidden="true">4.2.1.2.</strong> Serwery w Torze</a></li></ol></li><li class="chapter-item expanded "><a href="xbps/repositories/restricted.html"><strong aria-hidden="true">4.2.2.</strong> Pakiety nierozprowadzane</a></li><li class="chapter-item expanded "><a href="xbps/repositories/custom.html"><strong aria-hidden="true">4.2.3.</strong> Repozytoria zewnętrzne</a></li><li class="chapter-item expanded "><a href="xbps/repositories/signing.html"><strong aria-hidden="true">4.2.4.</strong> Podpisywanie repositoriów</a></li></ol></li><li class="chapter-item expanded "><a href="xbps/troubleshooting/index.html"><strong aria-hidden="true">4.3.</strong> Rozwiązywanie problemów z XBPS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="xbps/troubleshooting/common-issues.html"><strong aria-hidden="true">4.3.1.</strong> Częste problemy</a></li><li class="chapter-item expanded "><a href="xbps/troubleshooting/static.html"><strong aria-hidden="true">4.3.2.</strong> Statyczny XBPS</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">5.</strong> Współtworzenie</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/void-docs/index.html"><strong aria-hidden="true">5.1.</strong> Współtworzenie tego podręcznika</a></li></ol></li></ol>
			</nav>

			<!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
			<script type="text/javascript">
				document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
	document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
	Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
		link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
	});
			</script>

			<div id="page-wrapper">
				
				<div id="search-wrapper" class="hidden">
					<form id="searchbar-outer" class="searchbar-outer">
						<input type="search" name="search" id="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
					</form>
					<div id="searchresults-outer" class="searchresults-outer hidden">
						<div id="searchresults-header" class="searchresults-header"></div>
						<ul id="searchresults">
						</ul>
					</div>
				</div>
				

				<main id="main">
					<h1><a class="header" href="#about" id="about">About</a></h1>
<p>Welcome to the Void Handbook! Please be sure to read the &quot;<a href="about/./about-this-handbook.html">About This
Handbook</a>&quot; section to learn how to use this
documentation effectively. A local copy of this handbook, in several
formats, can be <a href="about/../xbps/index.html">installed</a> via the <code>void-docs</code> package
and accessed with the <a href="https://man.voidlinux.org/void-docs.1">void-docs(1)</a>
utility.</p>
<p>Void is an independent, <a href="https://en.wikipedia.org/wiki/Rolling_release">rolling
release</a> Linux distribution,
developed from scratch rather than as a fork, with a focus on stability over
<a href="https://en.wikipedia.org/wiki/Bleeding_edge_technology">bleeding-edge</a>. In
addition, there are several features that make Void unique:</p>
<ul>
<li>The <a href="https://github.com/void-linux/xbps">XBPS</a> package manager, which is
extremely fast, developed in-house, and performs checks when installing
updates to ensure that libraries are not changed to incompatible versions
which can break dependencies.</li>
<li>The <a href="https://musl.libc.org/">musl libc</a>, which focuses on standards compliance
and correctness, has first class support. This allows us to build certain
components for musl systems statically, which would not be practical on glibc
systems.</li>
<li>The <a href="https://www.libressl.org/">LibreSSL</a> fork is used instead of the mainline
OpenSSL library. Developed as part of the OpenBSD project, LibreSSL is
dedicated to the security, quality, and maintainability of this critical
library.</li>
<li><a href="about/../config/services/index.html">runit</a> is used for
<a href="https://man.voidlinux.org/init.8">init(8)</a> and service supervision. This
allows Void to support musl as a second libc choice, which would not be
possible with <a href="https://www.freedesktop.org/wiki/Software/systemd/">systemd</a>.
A side effect of this decision is a core system with clean and efficient
operation, and a small code base.</li>
</ul>
<p>Void is developed in the spare time of a handful of developers, and is
generally considered stable enough for daily use. We do this for fun and
hope that our work will be useful to others.</p>
<p>The name &quot;Void&quot; comes from the C literal <code>void</code>. It was chosen rather
randomly, and has no deeper meaning.</p>
<h1><a class="header" href="#history" id="history">History</a></h1>
<p>Knowledge of the ancients, grepped from the Git logs themselves:</p>
<ul>
<li>2008-09-26: first Git import of
<a href="https://github.com/void-linux/void-packages">void-packages</a></li>
<li>2009-08-17: first Git import of <a href="https://github.com/void-linux/xbps">xbps</a></li>
<li>2011-06-25: first systemd commit in void-packages</li>
<li>2013-03-01: first <a href="https://musl.libc.org/">musl</a> toolchains added</li>
<li>2014-07-14: begin switching to <a href="https://www.libressl.org/">LibreSSL</a></li>
<li>2014-07-28: switch from systemd to <a href="http://smarden.org/runit/">runit</a></li>
<li>2015-07-09: full aarch64 support with <code>linux4.1</code></li>
<li>2018-07-06: first use of <a href="https://github.com/void-linux/void-infrastructure/tree/master/terraform">Terraform for GitHub
permissions</a>,
for increased transparency</li>
</ul>
<h1><a class="header" href="#about-this-handbook" id="about-this-handbook">About This Handbook</a></h1>
<p>This handbook is not an extensive guide on how to use and configure common
Linux software. The purpose of this document is to explain how to install,
configure, and maintain Void Linux systems, and to highlight the differences
between common Linux distributions and Void.</p>
<p>To search for a particular term within the Handbook, select the 'magnifying
glass' icon, or press 's'.</p>
<p>Those looking for tips and tricks on how to configure a Linux system in
general should consult upstream software documentation. Additionally, the
<a href="https://wiki.archlinux.org/">Arch Wiki</a> provides a fairly comprehensive
outline of common Linux software configuration, and a variety of internet
search engines are available for further assistance.</p>
<h2><a class="header" href="#reading-the-manuals" id="reading-the-manuals">Reading The Manuals</a></h2>
<p>While this handbook does not provide a large amount of copy and paste
configuration instructions, it does provide links to the <a href="https://man.voidlinux.org/">man
pages</a> for the referenced software wherever
possible.</p>
<p>To learn how to use the <a href="https://man.voidlinux.org/man.1">man(1)</a> man page
viewer, run the command <code>man man</code>. It can be configured by editing
<code>/etc/man.conf</code>; read <a href="https://man.voidlinux.org/man.conf.5">man.conf(5)</a>
for details.</p>
<p>Void uses the <a href="https://mandoc.bsd.lv/">mandoc</a> toolset for man pages. mandoc
was formerly known as &quot;mdocml&quot;, and is provided by the <code>mdocml</code> package.</p>
<h2><a class="header" href="#example-commands" id="example-commands">Example Commands</a></h2>
<p>Examples in this guide may have snippets of commands to be run in your
shell.  When you see these, any line beginning with <code>$</code> is run as your
normal user.  Lines beginning with <code>#</code> are run as <code>root</code>. After either of
these lines, there may be example output from the command.</p>
<h3><a class="header" href="#placeholders" id="placeholders">Placeholders</a></h3>
<p>Some examples include text with placeholders. Placeholders indicate where
you should substitute the appropriate information. For example:</p>
<p><code># ln -s /etc/sv/&lt;service_name&gt; /var/service/</code></p>
<p>This means you need to substitute the text <code>&lt;service_name&gt;</code> with the actual
service name.</p>
<h1><a class="header" href="#infradocs" id="infradocs">InfraDocs</a></h1>
<p><a href="https://infradocs.voidlinux.org/">InfraDocs</a> is the meta-manual for the
Void project systems management.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>This section includes general information about the process of installing
Void.  For specific guides, see the &quot;<a href="installation/./guides/index.html">Advanced
Installation</a>&quot; section.</p>
<h2><a class="header" href="#base-system-requirements" id="base-system-requirements">Base system requirements</a></h2>
<p>Void can be installed on very minimalist hardware, though we recommend the
following minimums for most installations:</p>
<table><thead><tr><th>Architecture</th><th>CPU</th><th>RAM</th><th>Storage</th></tr></thead><tbody>
<tr><td>x86_64-glibc</td><td>x86_64</td><td>96MB</td><td>700MB</td></tr>
<tr><td>x86_64-musl</td><td>x86_64</td><td>96MB</td><td>600MB</td></tr>
<tr><td>i686-glibc</td><td>Pentium 4 (SSE2)</td><td>96MB</td><td>700MB</td></tr>
</tbody></table>
<p>Note that flavor installations require more resources; how much more depends
on the flavor.</p>
<p>Void is not available for the i386, i486, or i586 architectures.</p>
<p>Before installing musl Void, please read <a href="installation/./musl.html">the &quot;musl&quot; section</a> of
this Handbook, so that you are aware of software incompatibilities.</p>
<p>It is highly recommended to have a network connection available during
install to download updates, but this is not required. ISO images contain
installation data on-disk and can be installed without network connectivity.</p>
<h2><a class="header" href="#downloading-installation-media" id="downloading-installation-media">Downloading installation media</a></h2>
<p>The most recent live images and rootfs tarballs can be downloaded from
<a href="https://alpha.de.repo.voidlinux.org/live/current/">https://alpha.de.repo.voidlinux.org/live/current/</a>. They can also be
downloaded from <a href="installation/../xbps/repositories/mirrors/index.html">other
mirrors</a>. Previous releases can be
found under <a href="https://alpha.de.repo.voidlinux.org/live/">https://alpha.de.repo.voidlinux.org/live/</a>, organized by date.</p>
<h3><a class="header" href="#verifying-images" id="verifying-images">Verifying images</a></h3>
<p>Each image release's directory contains two files used to verify the
image(s)  you download. First, there is a <code>sha256.txt</code> file containing image
checksums to verify the integrity of the downloaded images. Second is the
<code>sha256.sig</code> file, used to verify the authenticity of the checksums.</p>
<p>It is necessary to verify both the image's integrity and authenticity. It
is, therefore, recommended that you download both files.</p>
<h4><a class="header" href="#verifying-image-integrity" id="verifying-image-integrity">Verifying image integrity</a></h4>
<p>You can verify the integrity of a downloaded file using
<a href="https://man.voidlinux.org/sha256sum.1">sha256sum(1)</a> with the <code>sha256.txt</code>
file downloaded above. The following command will check the integrity of
only the image(s) you have downloaded:</p>
<pre><code class="language-$sha256sum-c--ignore-missingsha256.txt">void-live-x86_64-musl-20170220.iso: OK ```

This verifies that the image is not corrupt.

### Verifying digital signature

Prior to using any image you're strongly encouraged to validate the
signatures on the image to ensure they haven't been tampered with.

Current images are signed using a signify key that is specific to the
release.  If you're on Void already, you can obtain the keys from the
`void-release-keys` package, which will be downloaded using your existing
XBPS trust relationship with your mirror. You will also need a copy of
[signify(1)](https://man.voidlinux.org/signify.1); on Void this is provided
by the `outils` package.

To obtain `signify` when using a Linux distribution or operating system
other than Void Linux:

- Install the `signify` package in Arch Linux and Arch-based distros.
- Install the `signify-openbsd` package in Debian and Debian-based distros.
- Install the package listed
   [here](https://repology.org/project/signify-openbsd/versions) for your
   distribution.
- Install `signify-osx` with homebrew in macOS.

If you can't obtain `signify` for some reason (e.g. you are on Windows and
can't use WSL or MinGW), you can use
[minisign(1)](https://man.voidlinux.org/minisign.1) to verify the file.

If you are not currently using Void Linux, it will also be necessary to
obtain the appropriate signing key from our Git repository
[here](https://github.com/void-linux/void-packages/tree/master/srcpkgs/void-release-keys/files/).

Once you've obtained the key, you can verify your image with the
`sha256.sig` file. The following example demonstrates the verification of
the GCP musl filesystem from the 20191109 release:

``` $ signify -C -p /etc/signify/void-release-20191109.pub -x sha256.sig
void-GCP-musl-PLATFORMFS-20191109.tar.xz Signature Verified
void-GCP-musl-PLATFORMFS-20191109.tar.xz: OK ```

If the verification process does not produce the expected &quot;OK&quot; status, do
not use it! Please alert the Void Linux team of where you got the image and
how you verified it, and we will follow up on it.

For verification with `minisign`, it is necessary to rename the `sha256.sig`
file to `sha256.txt.minisig` and remove the first line from the `.pub`
release key. The following example demonstrates the verification of the
`sha256.txt` file from the 20191109 release:

``` $ minisign -Vm sha256.txt -f -p void-release-20191109.pub
void-release-20191109.pub: Success ```

The same warning as above applies. If the verification process isn't
successful, do not use the file - warn the Void Linux team about it.
</code></pre>
<h1><a class="header" href="#live-installers" id="live-installers">Live Installers</a></h1>
<p>Void provides live installer images containing a base set of utilities, an
installer program, and package files to install a new Void system. These
live images are also useful for repairing a system that is not able to boot
or function properly.</p>
<p>There are <code>x86_64</code> images for both <code>glibc</code> and <code>musl</code> based systems. There
are also images for <code>i686</code>, but only <code>glibc</code> is supported for this
architecture.  Live installers are not provided for other
architectures. Users of other architectures will need to use rootfs
tarballs, or perform an installation manually.</p>
<h2><a class="header" href="#installer-images" id="installer-images">Installer images</a></h2>
<p>Void releases two types of images: base images and &quot;flavor&quot; images. Linux
beginners are encouraged to try one of the more full-featured flavor images,
but more advanced users may often prefer to start from a base image to
install only the packages they need.</p>
<h3><a class="header" href="#base-images" id="base-images">Base images</a></h3>
<p>The base images provide only a minimal set of packages to install a usable
Void system. These base packages are only those needed to configure a new
machine, update the system, and install additional packages from
repositories.</p>
<h3><a class="header" href="#flavor-images" id="flavor-images">Flavor images</a></h3>
<p>Each of the Void &quot;flavor&quot; images includes a full desktop environment, web
browser, and basic applications configured for that environment. The only
difference from the base images is the additional packages and services
installed.</p>
<p>The install process for each of the flavor images is the same as the base
images, except that you <strong>must</strong> select the <code>Local</code> source when
installing. If you select <code>Network</code> instead, the installer will download and
install the latest version of the base system, without any additional
packages included on the live image.</p>
<h4><a class="header" href="#comparison-of-flavor-images" id="comparison-of-flavor-images">Comparison of flavor images</a></h4>
<p>Here's a quick overview of the main components and applications included
with each flavor:</p>
<table><thead><tr><th></th><th>Enlightenment</th><th>Cinnamon</th><th>LXDE</th><th>LXQT</th><th>MATE</th><th>XFCE</th></tr></thead><tbody>
<tr><td>Window Manager</td><td>Enlightenment Window Manager</td><td>Mutter (Muffin)</td><td>Openbox</td><td>Openbox</td><td>Metacity (Marco)</td><td>xfwm4</td></tr>
<tr><td>File Manager</td><td>Enlightenment File Manager</td><td>Nemo</td><td>PCManFM</td><td>PCManFM-Qt</td><td>Caja</td><td>Thunar</td></tr>
<tr><td>Web Browser</td><td>Firefox ESR</td><td>Firefox ESR</td><td>Firefox ESR</td><td>QupZilla</td><td>Firefox ESR</td><td>Firefox ESR</td></tr>
<tr><td>Terminal</td><td>Terminology</td><td>gnome-terminal</td><td>LXTerminal</td><td>QTerminal</td><td>MATE terminal</td><td>xfce4-Terminal</td></tr>
<tr><td>Document Viewer</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Atril (PS/PDF)</td><td>-</td></tr>
<tr><td>Plain text viewer</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Pluma</td><td>Mousepad</td></tr>
<tr><td>Image viewer</td><td>-</td><td>-</td><td>GPicView</td><td>LXImage</td><td>Eye of MATE</td><td>Ristretto</td></tr>
<tr><td>Archive unpacker</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Engrampa</td><td>-</td></tr>
<tr><td>Other</td><td>Mixer, EConnMan (connection manager), Elementary Test</td><td>-</td><td>LXTask (task manager), MIME type editor</td><td>Screen grabber</td><td>Screen grabber, file finder, MATE color picker, MATE font viewer, Disk usage analyzer, Power statistics, System monitor (task manager), Dictionary, Log file viewer</td><td>Bulk rename, Orage Globaltime, Orage Calendar, Task Manager, Parole Media Player, Audio Mixer, MIME type editor, Application finder</td></tr>
</tbody></table>
<h1><a class="header" href="#prepare-installation-media" id="prepare-installation-media">Prepare Installation Media</a></h1>
<p>After <a href="installation/live-images/../index.html#downloading-installation-media">downloading a live
image</a>, it must be written to
bootable media, such as a USB drive, SD card, or CD/DVD.</p>
<h2><a class="header" href="#create-a-bootable-usb-drive-or-sd-card-on-linux" id="create-a-bootable-usb-drive-or-sd-card-on-linux">Create a bootable USB drive or SD card on Linux</a></h2>
<h3><a class="header" href="#identify-the-device" id="identify-the-device">Identify the Device</a></h3>
<p>Before writing the image, identify the device you'll write it to. You can do
this using <a href="https://man.voidlinux.org/man8/fdisk.8">fdisk(8)</a>. After
connecting the storage device, identify the device path by running:</p>
<pre><code class="language-#fdisk-lDisk/dev/sda:7.5GiB 8036286464bytes 15695872sectors">Disk model: Your USB Device's Model Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes I/O size
(minimum/optimal): 512 bytes / 512 bytes ```

In the example above, the output shows the USB device as `/dev/sda`. On
Linux, the path to the device will typically be in the form of `/dev/sdX`
(where X is a number) for USB devices, `/dev/mmcblkX` for SD cards, or other
variations depending on the device. You can use the model and size (`7.5GiB`
above, after the path) to identify the device if you're not sure what path
it will have.

Once you've identified the device you'll use, ensure it's not mounted by
unmounting it with [umount(8)](https://man.voidlinux.org/man8/umount.8):

``` # umount /dev/sdX umount: /dev/sdX: not mounted.  ```

### Write the live image

The [dd(1)](https://man.voidlinux.org/man1/dd.1) command can be used to copy
a live image to a storage device. Using `dd`, write the live image to the
device:

**Warning**: this will destroy any data currently on the referenced device.
Exercise caution.

``` # dd bs=4M if=/path/to/void-live-ARCH-DATE-VARIANT.iso of=/dev/sdX 90+0
records in 90+0 records out 377487360 bytes (377 MB, 360 MiB) copied,
0.461442 s, 818 MB/s ```

`dd` won't print anything until it's completed (or if it failed), so,
depending on the device, this can take a few minutes or longer. You can
enable printing by adding `status=progress` to the command if using GNU
coreutils `dd`.

Finally, ensure all data is flushed before disconnecting the device:

``` $ sync ```

The number of records, amount copied, and rates will all vary depending on
the device and the live image you chose.

## Burning to a CD or DVD

Any disk burning application should be capable of writing the `.iso` file to
a CD or DVD. The following free software applications are available
(cross-platform support may vary):

- [Brasero](https://wiki.gnome.org/Apps/Brasero/)  -
[K3B](https://userbase.kde.org/K3b)  -
[Xfburn](https://goodies.xfce.org/projects/applications/xfburn)

It should be noted that, with a CD or DVD, live sessions will be less
responsive than with a USB stick or hard drive.
</code></pre>
<h1><a class="header" href="#partitioning-notes" id="partitioning-notes">Partitioning Notes</a></h1>
<p>Partitioning for a modern Linux distribution is generally very simple,
however the introduction of GPT and UEFI booting does bring new complexity
to the process. When creating your new partition table you will need a
partition for the root filesystem, along with a swap partition and possibly
another partition or two to facilitate booting, if required.</p>
<p>Note that if the disk has already been initialized, the top of the <code>cfdisk</code>
screen will show the partition layout already present: <code>Label: dos</code> for the
MBR scheme, <code>Label: gpt</code> for the GPT scheme. If you just want to erase the
partition table before starting the installer, use <code>wipefs(8)</code>. Otherwise,
you can run <code>cfdisk(8)</code> manually with the <code>-z</code> option to start with an
uninitialized disk layout; <code>cfdisk</code> will prompt you for the label type
before continuing to the main screen.</p>
<p>The following sections will detail the options for partition configuration.</p>
<h2><a class="header" href="#bios-system-notes" id="bios-system-notes">BIOS system notes</a></h2>
<p>It is recommended that you create an MBR partition table if you are using a
BIOS boot system. This will limit the number of partitions you create to
four.</p>
<p>It is possible to use a GPT partition table on a BIOS system, but GRUB will
require a special partition to boot properly. This partition should be at
the beginning of your disk and have a size of 1MB, with type <code>BIOS boot</code>
(GUID <code>21686148-6449-6E6F-744E-656564454649</code>). Don't create any filesystem
in it. GRUB should then install itself successfully.</p>
<h2><a class="header" href="#uefi-system-notes" id="uefi-system-notes">UEFI system notes</a></h2>
<p>UEFI users are recommended to create a GPT partition table. UEFI booting
with GRUB also requires a special partition of the type <code>EFI System</code> with a
<code>vfat</code> filesystem mounted at <code>/boot/efi</code>. A reasonable size for this
partition could be between 200MB and 1GB. With this partition setup during
the live image installation, the installer should successfully set up the
bootloader automatically.</p>
<h2><a class="header" href="#swap-partitions" id="swap-partitions">Swap partitions</a></h2>
<p>A swap partition is not strictly required, but recommended for systems with
low RAM. If you want to use hibernation, you will need a swap partition. The
following table has recommendations for swap partition size.</p>
<table><thead><tr><th>System RAM</th><th>Recommended swap space</th><th>Swap space if using hibernation</th></tr></thead><tbody>
<tr><td>&lt; 2GB</td><td>2x the amount of RAM</td><td>3x the amount of RAM</td></tr>
<tr><td>2-8GB</td><td>Equal to amount of RAM</td><td>2x the amount of RAM</td></tr>
<tr><td>8-64GB</td><td>At least 4GB</td><td>1.5x the amount of RAM</td></tr>
<tr><td>64GB</td><td>At least 4GB</td><td>Hibernation not recommended</td></tr>
</tbody></table>
<h2><a class="header" href="#boot-partition-optional" id="boot-partition-optional">Boot partition (optional)</a></h2>
<p>On most modern systems, a separate <code>/boot</code> partition is no longer necessary
to boot properly. If you choose to use one, note that Void does not remove
old kernels after updates by default and also that the kernel tends to
increase in size with each new version, so plan accordingly (e.g. <code>/boot</code>
with one Linux 5.x <code>x86_64</code> kernel and GRUB occupies about 60MB).</p>
<h2><a class="header" href="#other-partitions" id="other-partitions">Other partitions</a></h2>
<p>It is fine to install your system with only a large root partition, but you
may create other partitions if you want. One helpful addition could be a
separate partition for your <code>/home</code> directory. This way if you need to
reinstall Void (or another distribution) you can save the data and
configuration files in your home directory for your new system.</p>
<h1><a class="header" href="#installation-guide" id="installation-guide">Installation Guide</a></h1>
<p>Once you have <a href="installation/live-images/../index.html#downloading-installation-media">downloaded</a> a
Void image to install and <a href="installation/live-images/./prep.html">prepared</a> your install media, you are
ready to install Void Linux.</p>
<p>Before you begin installation, you should determine whether your machine
boots using BIOS or UEFI. This will affect how you plan partitions. See
<a href="installation/live-images/./partitions.html">Partitioning Notes</a> for more detail.</p>
<p>The following features are not supported by the installer script:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Logical_volume_management">LVM</a>  -
<a href="https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup">LUKS</a>  -
<a href="https://en.wikipedia.org/wiki/ZFS">ZFS</a></li>
</ul>
<h2><a class="header" href="#booting" id="booting">Booting</a></h2>
<p>Boot your machine from the install media you created. If you have enough
RAM, there is an option on the boot screen to load the entire image into
ram, which will take some time but speed up the rest of the install process.</p>
<p>Once the live image has booted, log in as <code>root</code> with password <code>voidlinux</code>
and run:</p>
<p><code># void-installer</code></p>
<p>The following sections will detail each screen of the installer.</p>
<h2><a class="header" href="#keyboard" id="keyboard">Keyboard</a></h2>
<p>Select the keymap for your keyboard; standard &quot;qwerty&quot; keyboards will
generally use the &quot;us&quot; keymap.</p>
<h2><a class="header" href="#network" id="network">Network</a></h2>
<p>Select your primary network interface. If you do not choose to use DHCP, you
will be prompted to provide an IP address, gateway, and DNS servers.</p>
<p>If you intend to use a wireless connection during the installation, you may
need to configure it manually using wpa_supplicant and dhcpcd manually
before running <code>void-installer</code>.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>To install packages provided on the install image, select
<code>Local</code>. Otherwise, you may select <code>Network</code> to download the latest packages
from the Void repository.</p>
<p><strong>Warning!</strong>: If you are installing a desktop environment from a ''flavor''
image, you MUST choose <code>Local</code> for the source!</p>
<h2><a class="header" href="#hostname" id="hostname">Hostname</a></h2>
<p>Select a hostname for your computer (that is all lowercase, with no spaces.)</p>
<h2><a class="header" href="#locale" id="locale">Locale</a></h2>
<p>Select your default locale settings. This option is for glibc only, as musl
does not currently support locales.</p>
<h2><a class="header" href="#timezone" id="timezone">Timezone</a></h2>
<p>Select your timezone based on standard timezone options.</p>
<h2><a class="header" href="#root-password" id="root-password">Root password</a></h2>
<p>Enter and confirm your <code>root</code> password for the new installation. The
password will not be shown on screen.</p>
<h2><a class="header" href="#user-account" id="user-account">User account</a></h2>
<p>Choose a login (default <code>void</code>) and a descriptive name for that login. Then
enter and confirm the password for the new user. You will then be prompted
to verify the groups for this new user. They are added to the <code>wheel</code> group
by default and will have <code>sudo</code> access.</p>
<h2><a class="header" href="#bootloader" id="bootloader">Bootloader</a></h2>
<p>Select the disk to install a bootloader on when Void is installed. You may
select <code>none</code> to skip this step and install a bootloader manually after
completing the installation process. If installing a bootloader, you will
also be asked whether or not you want a graphical terminal for the GRUB
menu.</p>
<h2><a class="header" href="#partition" id="partition">Partition</a></h2>
<p>Next, you will need to partition your disks. Void does not provide a preset
partition scheme, so you will need to create your partitions manually with
<a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a>. You will be prompted with a
list of disks. Select the disk you want to partition and the installer will
launch <code>cfdisk</code> for that disk. Remember you must write the partition table
to the drive before you exit the partition editor.</p>
<p>If using UEFI, it is recommended you select GPT for the partition table and
create a partition (typically between 200MB-1GB) of type <code>EFI System</code>, which
will be mounted at <code>/boot/efi</code>.</p>
<p>If using BIOS, it is recommended you select MBR for the partition table.
Advanced users may use GPT but will need to <a href="installation/live-images/./partitions.html#bios-system-notes">create a special BIOS
partition</a> for GRUB to boot.</p>
<p>See the <a href="installation/live-images/./partitions.html">Partitioning Notes</a> for more details about
partitioning your disk.</p>
<h2><a class="header" href="#filesystems" id="filesystems">Filesystems</a></h2>
<p>Create the filesystems for each partition you have created. For each
partition you will be prompted to choose a filesystem type, whether you want
to create a new filesystem on the partition, and a mount point, if
applicable. When you are finished, select <code>Done</code> to return to the main menu.</p>
<p>If using UEFI, create a <code>vfat</code> filesystem and mount it at <code>/boot/efi</code>.</p>
<h2><a class="header" href="#review-settings" id="review-settings">Review settings</a></h2>
<p>It is a good idea to review your settings before proceeding. Use the right
arrow key to select the settings button and hit <code>&lt;enter&gt;</code>. All your
selections will be shown for review.</p>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>Selecting <code>Install</code> from the menu will start the installer. The installer
will create all the filesystems selected, and install the base system
packages. It will then generate an initramfs and install a GRUB2 bootloader
to the bootable partition.</p>
<p>These steps will all run automatically, and after the installation is
completed successfully, you can reboot into your new Void Linux install!</p>
<h2><a class="header" href="#post-installation" id="post-installation">Post installation</a></h2>
<p>After booting into your Void installation for the first time, <a href="installation/live-images/../../xbps/index.html#updating">perform a
system update</a>.</p>
<h1><a class="header" href="#advanced-installation-guides" id="advanced-installation-guides">Advanced Installation Guides</a></h1>
<p>This section contains guides for more specific or complex use-cases.</p>
<h2><a class="header" href="#section-contents" id="section-contents">Section Contents</a></h2>
<ul>
<li><a href="installation/guides/./chroot.html">Installing Void via chroot (x86 or x86_64)</a>  - <a href="installation/guides/./fde.html">Installing
Void with Full Disk Encryption</a>  - <a href="installation/guides/./arm-devices/index.html">ARM
Devices</a></li>
</ul>
<h1><a class="header" href="#installation-via-chroot-x86x86_64" id="installation-via-chroot-x86x86_64">Installation via chroot (x86/x86_64)</a></h1>
<p>This guide details the process of manually installing Void via a chroot on
an x86 or x86_64 PC architecture. It is assumed that you have a familiarity
with Linux, but not necessarily with installing a Linux system via a
chroot. This guide can be used to create a a &quot;typical&quot; setup, using a single
partition on a single SATA/IDE/USB disk. Each step may be modified to create
less typical setups, such as <a href="installation/guides/./fde.html">full disk encryption</a>.</p>
<p>Void provides two options for bootstrapping the new installation. The <strong>XBPS
method</strong> uses the <a href="installation/guides/../../xbps/index.html">XBPS Package Manager</a> running on a
host operating system to install the base system. The <strong>ROOTFS method</strong>
installs the base system by unpacking a ROOTFS tarball.</p>
<p>The <strong>XBPS method</strong> requires that the host operating system have XBPS
installed.  This may be an existing installation of Void, an official <a href="installation/guides/../live-images/prep.html">live
image</a>, or any Linux installation running a
<a href="installation/guides/../../xbps/troubleshooting/static.html">statically linked XBPS</a>.</p>
<p>The <strong>ROOTFS method</strong> requires only a host operating system that can enter a
Linux chroot and that has both <a href="https://man.voidlinux.org/tar.1">tar(1)</a> and
<a href="https://man.voidlinux.org/xz.1">xz(1)</a> installed. This method may be
preferable if you wish to install Void using a different Linux distribution.</p>
<h2><a class="header" href="#prepare-filesystems" id="prepare-filesystems">Prepare Filesystems</a></h2>
<p><a href="installation/guides/../live-images/partitions.html">Partition your disks</a> and format them using
<a href="https://man.voidlinux.org/mke2fs.8">mke2fs(8)</a>,
<a href="https://man.voidlinux.org/mkfs.xfs.8">mkfs.xfs(8)</a>,
<a href="https://man.voidlinux.org/mkfs.btrfs.8">mkfs.btrfs(8)</a> or whatever tools
are necessary for your filesystem(s) of choice.</p>
<p><a href="https://man.voidlinux.org/mkfs.vfat.8">mkfs.vfat(8)</a> is also available to
create FAT32 partitions. However, due to restrictions associated with FAT
filesystems, it should only be used when no other filesystem is suitable
(such as for the EFI System Partition).</p>
<p><a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a> and
<a href="https://man.voidlinux.org/fdisk.8">fdisk(8)</a> are available on the live
images for partitioning, but you may wish to use
<a href="https://man.voidlinux.org/gdisk.8">gdisk(8)</a> (from the package <code>gptfdisk</code>)
or <a href="https://man.voidlinux.org/parted.8">parted(8)</a> instead.</p>
<p>For a UEFI booting system, make sure to create an EFI System Partition
(ESP).  The ESP should have the partition type &quot;EFI System&quot; (code <code>EF00</code>)
and be formatted as FAT32 using
<a href="https://man.voidlinux.org/mkfs.vfat.8">mkfs.vfat(8)</a>.</p>
<p>If you're unsure what partitions to create, create a 1GB partition of type
&quot;EFI System&quot; (code <code>EF00</code>), then create a second partition of type &quot;Linux
Filesystem&quot; (code <code>8300</code>) using the remainder of the drive.</p>
<p>Format these partitions as FAT32 and ext4, respectively:</p>
<p><code># mkfs.vfat /dev/sda1 # mkfs.ext4 /dev/sda2</code></p>
<h3><a class="header" href="#create-a-new-root-and-mount-filesystems" id="create-a-new-root-and-mount-filesystems">Create a New Root and Mount Filesystems</a></h3>
<p>This guide will assume the new root filesystem is mounted on <code>/mnt</code>. You may
wish to mount it elsewhere.</p>
<p>If using UEFI, mount the EFI System Partition as <code>/mnt/boot/efi</code>.</p>
<p>For example, if <code>/dev/sda2</code> is to be mounted as <code>/</code> and <code>dev/sda1</code> is the
EFI System Partition:</p>
<pre><code class="language-#mount/dev/sda2/mnt/#mkdir-p/mnt/boot/efi/#mount/dev/sda1">/mnt/boot/efi/ ```

Initialize swap space, if desired, using
[mkswap(8)](https://man.voidlinux.org/mkswap.8).

## Base Installation

Follow only one of the two following subsections.

### The XBPS Method

Select a [mirror](../../xbps/repositories/mirrors/index.md) and use the
[appropriate URL](../../xbps/repositories/index.md#the-main-repository) for
the type of system you wish to install. For simplicity, save this URL to a
shell variable for later use, e.g.:

``` # REPO=https://alpha.de.repo.voidlinux.org/current ```

XBPS also needs to know what architecture is being installed. Available
options are `x86_64`, `x86_64-musl` and `i686` for PC architecture
computers. For example:

``` # ARCH=x86_64 ```

This architecture must be compatible with your current operating system, but
does not need to be the same. If your host is running an x86_64 operating
system, any of the three architectures can be installed (whether the host is
musl or glibc), but an i686 host can only install i686 distributions.

Use [xbps-install(1)](https://man.voidlinux.org/xbps-install.1) to bootstrap
the installation by installing the `base-system` metapackage:

``` # XBPS_ARCH=$ARCH xbps-install -S -r /mnt -R &quot;$REPO&quot; base-system ```

`xbps-install` might ask you to [verify the RSA
keys](../../xbps/troubleshooting/common-issues.md#verifying-rsa-keys) for
the packages you are installing.

### The ROOTFS Method

[Download a ROOTFS
tarball](https://voidlinux.org/download/#download-installable-base-live-images-and-rootfs-tarballs)
matching your architecture.

Unpack the tarball into the newly configured filesystems:

``` # tar xvf void-&lt;...&gt;-ROOTFS.tar.xz -C /mnt ```

## Configuration

With the exception of the section &quot;Install base-system (ROOTFS method
only)&quot;, the remainder of this guide is common to both the XBPS and ROOTFS
installation methods.

### Entering the Chroot

Mount the pseudo-filesystems needed for a chroot:

``` # mount --rbind /sys /mnt/sys &amp;&amp; mount --make-rslave /mnt/sys # mount
--rbind /dev /mnt/dev &amp;&amp; mount --make-rslave /mnt/dev # mount --rbind /proc
/mnt/proc &amp;&amp; mount --make-rslave /mnt/proc ```

Copy the DNS configuration into the new root so that XBPS can still download
new packages inside the chroot:

``` # cp /etc/resolv.conf /mnt/etc/ ```

Chroot into the new installation:

``` # PS1='(chroot) # ' chroot /mnt/ /bin/bash ```

### Install base-system (ROOTFS method only)

ROOTFS images generally contain out of date software, due to being a
snapshot of the time when they were built, and do not come with a complete
`base-system`.  Update the package manager and install `base-system`:

``` # xbps-install -Su xbps # xbps-install -u # xbps-install base-system #
xbps-remove base-voidstrap ```

### Installation Configuration

Specify the hostname in `/etc/hostname`. Go through the options in
[`/etc/rc.conf`](../../config/rc-files.md#rcconf). If installing a glibc
distribution, edit `/etc/default/libc-locales`, uncommenting desired
[locales](../../config/locales.md).

[nvi(1)](https://man.voidlinux.org/nvi.1) is available in the chroot, but
you may wish to install your preferred text editor at this time.

For glibc builds, generate locale files with:

``` (chroot) # xbps-reconfigure -f glibc-locales ```

### Set a Root Password

[Configure at least one super user
account](../../config/users-and-groups.md).  Other user accounts can be
configured later, but there should either be a root password, or a new user
account with [sudo(8)](https://man.voidlinux.org/sudo.8)  privileges.

To set a root password, run:

``` (chroot) # passwd ```

### Configure fstab

The [fstab(5)](https://man.voidlinux.org/fstab.5) file can be automatically
generated from currently mounted filesystems by copying the file
`/proc/mounts`:

``` (chroot) # cp /proc/mounts /etc/fstab ```

Remove lines in `/etc/fstab` that refer to `proc`, `sys`, `devtmpfs` and
`pts`.

Replace references to `/dev/sdXX`, `/dev/nvmeXnYpZ`, etc. with their
respective UUID, which can be found by running
[blkid(8)](https://man.voidlinux.org/blkid.8). Referring to filesystems by
their UUID guarantees they will be found even if they are assigned a
different name at a later time. In some situations, such as booting from
USB, this is absolutely essential. In other situations, disks will always
have the same name unless drives are physically added or removed. Therefore,
this step may not be strictly necessary, but is almost always recommended.

Change the last zero of the entry for `/` to `1`, and the last zero of every
other line to `2`. These values configure the behaviour of
[fsck(8)](https://man.voidlinux.org/fsck.8).

For example, the partition scheme used throughout previous examples yields
the following `fstab`:

</code></pre>
<p>/dev/sda1       /boot/EFI   vfat    rw,relatime,[...]       0 0
/dev/sda2       /           ext4    rw,relatime             0 0</p>
<pre><code>
The information from `blkid` results in the following `/etc/fstab`:

</code></pre>
<p>UUID=6914[...]  /boot/EFI   vfat    rw,relatime,[...]       0 2
UUID=dc1b[...]  /           ext4    rw,relatime             0 1</p>
<pre><code>
Note: The output of `/proc/mounts` will have a single space between each
field.  The columns are aligned here for readability.

Add an entry to mount `/tmp` in RAM:

</code></pre>
<p>tmpfs           /tmp        tmpfs   defaults,nosuid,nodev   0 0</p>
<pre><code>
If using swap space, add an entry for any swap partitions:

</code></pre>
<p>UUID=1cb4[...]  swap        swap    rw,noatime,discard      0 0</p>
<pre><code>
## Installing GRUB

Use
[grub-install](https://www.gnu.org/software/grub/manual/grub/html_node/Installing-GRUB-using-grub_002dinstall.html)
to install GRUB onto your boot disk.

**On a BIOS computer**, install the package `grub`, then run `grub-install
/dev/sdX`, where `/dev/sdX` is the drive (not partition) that you wish to
install GRUB to. For example:

``` (chroot) # xbps-install grub (chroot) # grub-install /dev/sda ```

**On a UEFI computer**, install either `grub-x86_64-efi` or `grub-i386-efi`,
depending on your architecture, then run `grub-install`, optionally specifying a
bootloader label (this label may be used by your computer's firmware when
manually selecting a boot device):

``` (chroot) # xbps-install grub-x86_64-efi (chroot) # grub-install
--target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=&quot;Void&quot; ```

If installing onto a removable disk (such as USB), add the option
`--removable` to the `grub-install` command.

## Finalization

Use [xbps-reconfigure(1)](https://man.voidlinux.org/xbps-reconfigure.1) to
ensure all installed packages are configured properly:

``` (chroot) # xbps-reconfigure -fa ```

This will make [dracut(8)](https://man.voidlinux.org/dracut.8) generate an
initramfs, and will make GRUB generate a working configuration.

At this point, the installation is complete. Exit the chroot and reboot your
computer:

``` (chroot) # exit # shutdown -r now ```

After booting into your Void installation for the first time, [perform a
system update](../../xbps/index.md#updating).
</code></pre>
<h1><a class="header" href="#full-disk-encryption" id="full-disk-encryption">Full Disk Encryption</a></h1>
<p>Your drive's block device and other information may be different, so make
sure it is correct.</p>
<p>Boot the live image and login.</p>
<p>Create a single physical partition on the disk using <code>cfdisk</code>, marking it
bootable. For an MBR system, the partition layout should look like the
following.</p>
<pre><code class="language-#fdisk-l/dev/sdaDisk/dev/sda:48GiB 51539607552bytes 100663296">sectors Units: sectors of 1 * 512 = 512 bytes Sector size
(logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512
bytes / 512 bytes Disklabel type: dos Disk identifier: 0x4d532059

Device     Boot Start       End   Sectors Size Id Type
/dev/sda1  *     2048 100663295 100661248  48G 83 Linux
</code></pre>
<p>UEFI systems will need the disk to have a GPT disklabel and an EFI system
partition. The required size for this may vary depending on needs, but 100M
should be enough for most cases. For an EFI system, the partition layout
should look like the following.</p>
<pre><code class="language-#fdisk-l/dev/sdaDisk/dev/sda:48GiB 51539607552bytes 100663296">sectors Units: sectors of 1 * 512 = 512 bytes Sector size
(logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512
bytes / 512 bytes Disklabel type: gpt Disk identifier:
EE4F2A1A-8E7F-48CA-B3D0-BD7A01F6D8A0

Device      Start       End   Sectors  Size Type
/dev/sda1    2048    264191    262144  128M EFI System
/dev/sda2  264192 100663262 100399071 47.9G Linux filesystem
</code></pre>
<p>Configure the encrypted volume. <code>cryptsetup</code> defaults to LUKS2, yet GRUB
currently only has support for LUKS1, so it is critical to force LUKS1. Keep
in mind this will be <code>/dev/sda2</code> on EFI systems.</p>
<pre><code class="language-#cryptsetupluksFormat--typeluks1/dev/sda1">
WARNING!
========
This will overwrite data on /dev/sda1 irrevocably.

Are you sure? (Type uppercase yes): YES Enter passphrase: Verify passphrase:
</code></pre>
<p>Once the volume is created, it needs to be opened. Replace voidvm with an
appropriate name. Again, this will be <code>/dev/sda2</code> on EFI systems.</p>
<pre><code class="language-#cryptsetupluksOpen/dev/sda1voidvmEnterpassphrasefor/dev/sda1:"></code></pre>
<p>Once the LUKS container is opened, create the LVM volume group using that
partition.</p>
<pre><code># vgcreate voidvm /dev/mapper/voidvm
  Volume group &quot;voidvm&quot; successfully created
</code></pre>
<p>There should now be an empty volume group named <code>voidvm</code>.</p>
<p>Next, logical volumes need to be created for the volume group. For this
example, I chose 10G for <code>/</code>, 2G for <code>swap</code>, and will assign the rest to
<code>/home</code>.</p>
<pre><code># lvcreate --name root -L 10G voidvm
  Logical volume &quot;root&quot; created.
# lvcreate --name swap -L 2G voidvm
  Logical volume &quot;swap&quot; created.
# lvcreate --name home -l 100%FREE voidvm
  Logical volume &quot;home&quot; created.
</code></pre>
<p>Next, create the filesystems. The example below uses XFS as a personal
preference of the author. Any filesystem <a href="https://www.gnu.org/software/grub/manual/grub/grub.html#Features">supported by
GRUB</a> will
work.</p>
<pre><code># mkfs.xfs -L root /dev/voidvm/root
meta-data=/dev/voidvm/root       isize=512    agcount=4, agsize=655360 blks
...
# mkfs.xfs -L home /dev/voidvm/home
meta-data=/dev/voidvm/home       isize=512    agcount=4, agsize=2359040 blks
...
mkswap /dev/voidvm/swap
Setting up swapspace version 1, size = 2 GiB (2147479552 bytes)
</code></pre>
<p>Next, setup the chroot and install the base system.</p>
<pre><code class="language-#mount/dev/voidvm/root/mnt#fordirindevprocsysrun;domkdir-p">/mnt/$dir ; mount --rbind /$dir /mnt/$dir ; mount --make-rslave /mnt/$dir ;
done # mkdir -p /mnt/home # mount /dev/voidvm/home /mnt/home ```

On a UEFI system, the EFI system partition also needs to be mounted.

``` # mkfs.vfat /dev/sda1 # mkdir -p /mnt/boot/efi # mount /dev/sda1
/mnt/boot/efi ```

Before we enter the chroot to finish up configuration, we do the actual
install.

`xbps-install` might ask you to [verify the RSA
keys](../../xbps/index.md#verifying-rsa-keys) for the packages you are
installing.

``` # xbps-install -Sy -R https://alpha.de.repo.voidlinux.org/current -r
/mnt base-system lvm2 cryptsetup grub [*] Updating
`https://alpha.de.repo.voidlinux.org/current/x86_64-repodata' ...
x86_64-repodata: 1661KB [avg rate: 2257KB/s]
`https://alpha.de.repo.voidlinux.org/current' repository has been RSA signed
by &quot;Void Linux&quot; Fingerprint: 60:ae:0c:d6:f0:95:17:80:bc:93:46:7a:89:af:a3:2d
Do you want to import this public key? [Y/n] y 130 packages will be
downloaded: ...  ```

UEFI systems will have a slightly different package selection. The
installation command for a UEFI system will be as follows.

``` # xbps-install -Sy -R https://alpha.de.repo.voidlinux.org/current -r
/mnt base-system cryptsetup grub-x86_64-efi lvm2 ```

When it's done, we can enter the `chroot` and finish up the configuration.

``` # chroot /mnt # chown root:root / # chmod 755 / # passwd root # echo
voidvm &gt; /etc/hostname # echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf # echo
&quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/default/libc-locales # xbps-reconfigure -f
glibc-locales ```

The next step is editing `/etc/fstab`, which will depend on how you
configured and named your filesystems. For this example, the file should
look like this:

</code></pre>
<h1><a class="header" href="#file-system----dir-type--options-------------dump--pass" id="file-system----dir-type--options-------------dump--pass"><file system>	   <dir> <type>  <options>             <dump>  <pass></a></h1>
<p>tmpfs             /tmp  tmpfs   defaults,nosuid,nodev 0       0
/dev/voidvm/root  /     xfs     defaults              0       0
/dev/voidvm/home  /home xfs     defaults              0       0
/dev/voidvm/swap  swap  swap    defaults              0       0</p>
<pre><code>
UEFI systems will also have an entry for the EFI system partition.

``` /dev/sda1	/boot/efi	vfat	defaults	0	0 ```

Next, configure GRUB to be able to unlock the filesystem. Add the following
line to `/etc/default/grub`:

``` GRUB_ENABLE_CRYPTODISK=y ```

Next, the kernel needs to be configured to find the encrypted device. First,
find the UUID of the device.

``` # blkid -o value -s UUID /dev/sda1 135f3c06-26a0-437f-a05e-287b036440a4
</code></pre>
<p>Edit the <code>GRUB_CMDLINE_LINUX_DEFAULT=</code> line in <code>/etc/default/grub</code> and add
<code>rd.lvm.vg=voidvm rd.luks.uuid=&lt;UUID&gt;</code> to it. Make sure the UUID matches the
one for the <code>sda1</code> device found in the output of the
<a href="https://man.voidlinux.org/blkid.8">blkid(8)</a> command above.</p>
<p>And now to avoid having to enter the password twice on boot, a key will be
configured to automatically unlock the encrypted volume on boot. First,
generate a random key.</p>
<pre><code class="language-#ddbs=1count=64if=/dev/urandomof=/boot/volume.key64+0recordsin">64+0 records out 64 bytes copied, 0.000662757 s, 96.6 kB/s ```

Next, add the key to the encrypted volume.

``` # cryptsetup luksAddKey /dev/sda1 /boot/volume.key Enter any existing
passphrase: ```

Change the permissions to protect generated the key.

``` # chmod 000 /boot/volume.key # chmod -R g-rwx,o-rwx /boot ```

This keyfile also needs to be added to `/etc/crypttab`. Again, this will be
`/dev/sda2` on EFI systems.

</code></pre>
<p>voidvm   /dev/sda1   /boot/volume.key   luks</p>
<pre><code>
And then the keyfile and `crypttab` need to be included in the
initramfs. Create a new file at `/etc/dracut.conf.d/10-crypt.conf` with the
following line:

``` install_items+=&quot; /boot/volume.key /etc/crypttab &quot; ```

Next, install the boot loader to the disk.

``` # grub-install /dev/sda ```

Ensure an initramfs is generated:

``` # xbps-reconfigure -fa ```

Exit the `chroot`, unmount the filesystems, and reboot the system.

``` # exit # umount -R /mnt # reboot ```
</code></pre>
<h1><a class="header" href="#arm-devices" id="arm-devices">ARM Devices</a></h1>
<p>Void Linux provides packages and images for several ARM devices. Installing
Void on such devices can be done in several ways:</p>
<ul>
<li><a href="installation/guides/arm-devices/index.html#pre-built-images">Pre-built images</a>: images that can be flashed directly
onto an SD card or other storage medium, but which give you a limited
partition layout, and require manual expansion if you wish to increase the
size of the partitions;</li>
<li><a href="installation/guides/arm-devices/index.html#tarball-installation">Tarball installation</a>: PLATFORMFS and ROOTFS tarballs
that can be extracted to a previously prepared partition scheme; and</li>
<li><a href="installation/guides/arm-devices/index.html#chroot-installation">Chroot installation</a>: follows most of the steps
outlined in <a href="installation/guides/arm-devices/../chroot.html">the chroot guide</a>.</li>
</ul>
<p>This guide also outlines <a href="installation/guides/arm-devices/index.html#configuration">configuration steps</a> that are
mostly specific to such devices.</p>
<p>Since most of the commands in this guide will be run on external storage, it
is important to run <a href="https://man.voidlinux.org/sync.1">sync(1)</a> before
removing the device.</p>
<h2><a class="header" href="#installation-1" id="installation-1">Installation</a></h2>
<p>If you are installing Void Linux on one of the ARM devices covered in the
&quot;<a href="installation/guides/arm-devices/./platforms.html">Supported platforms</a>&quot; page, make sure to read its section
thoroughly.</p>
<h3><a class="header" href="#pre-built-images" id="pre-built-images">Pre-built images</a></h3>
<p>After <a href="installation/guides/arm-devices/../../index.html#downloading-installation-media">downloading and
verifying</a>  an image, it can
be written to the relevant media with
<a href="https://man.voidlinux.org/cat.1">cat(1)</a>,
<a href="https://man.voidlinux.org/pv.1">pv(1)</a>, or
<a href="https://man.voidlinux.org/dd.1">dd(1)</a>. For example, to flash it onto an SD
card located at <code>/dev/mmcblk0</code>:</p>
<p><code># dd if=&lt;image&gt;.img of=/dev/mmcblk0 bs=4M status=progress</code></p>
<h3><a class="header" href="#custom-partition-layout" id="custom-partition-layout">Custom partition layout</a></h3>
<p>Customizing an installation - for example, with a custom partition layout -
requires a more involved process. Two available options are:</p>
<ul>
<li><a href="installation/guides/arm-devices/index.html#tarball-installation">Tarball installation</a>; and - <a href="installation/guides/arm-devices/index.html#chroot-installation">Chroot
installation</a>.</li>
</ul>
<p>To prepare the storage for these installation methods, it is necessary to
partition the storage medium and then mount the partitions at the correct
mount points.</p>
<p>The usual partitioning scheme for ARM devices requires at least two
partitions, on a drive formatted with an MS-DOS partition table:</p>
<ul>
<li>one formatted as FAT32 with partition type <code>0c</code>, which will be mounted on
<code>/boot</code>;</li>
<li>one that can be formatted as any file system that Linux can boot from, such as
ext4, which will be mounted on <code>/</code>. If you're using an SD card, you can
create the ext4 file system with the <code>^has_journal</code> option - this disables
journaling, which might increase the drive's life, at the cost of a higher
chance of data loss.</li>
</ul>
<p>There are a variety of tools available for partitioning, e.g.
<a href="https://man.voidlinux.org/cfdisk.8">cfdisk(8)</a>.</p>
<p>To access the newly created file systems, it is necessary to mount
them. This guide will assume that the second partition will be mounted on
<code>/mnt</code>, but you may mount it elsewhere. To mount these filesystems, you can
use the commands below, replacing the device names with the appropriate ones
for your setup:</p>
<pre><code class="language-#mount/dev/mmcblk0p2/mnt#mkdir/mnt/boot#mount/dev/mmcblk0p1">/mnt/boot ```

#### Tarball installation

First, [download and verify](../../index.md#downloading-installation-media)
a PLATFORMFS or ROOTFS tarball for your desired platform and [prepare your
storage medium](#custom-partition-layout). Then, unpack the tarball onto the
file system using [tar(1)](https://man.voidlinux.org/tar.1):

``` # tar xvfp &lt;image&gt;.tar.xz -C /mnt ```

#### Chroot installation

It is also possible to perform a chroot installation, which can require the
`qemu-user-static` package together with either the `binfmt-support` or
`proot` package if a computer with an incompatible architecture (such as
i686) is being used. This guide explains how to use the
`qemu-&lt;platform&gt;-static` program from `qemu-user-static` with
[proot(1)](https://man.voidlinux.org/proot.1).

First, [prepare your storage medium](#custom-partition-layout). Then, follow
either the [XBPS chroot installation](../chroot.md#the-xbps-method) or the
[ROOTFS chroot installation](../chroot.md#the-rootfs-method) steps, using
the appropriate architecture and base packages, some of which are listed in
the &quot;[Supported Platforms](./platforms.md)&quot; section.

Finally, follow the [chroot configuration steps](../chroot.md#configuration)
steps, but instead of using the
[chroot(1)](https://man.voidlinux.org/chroot.1)  command to [enter the
chroot](../chroot.md#entering-the-chroot), use the following command,
replacing `&lt;platform&gt;` with `arm` for armv6l and armv7l devices, and with
`aarch64` for aarch64 devices:

``` # proot -q qemu-&lt;platform&gt;-static -r /mnt -w / ```

## Configuration

Some additional configuration steps need to be followed to guarantee a
working system. Configuring a [graphical
session](../../../config/graphical-session/index.md) should work as normal.

### Logging in

For the pre-built images and tarball installations, the `root` user password
is `voidlinux`.

### fstab

The `/boot` partition should be added to `/etc/fstab`, with an entry similar
to the one below. It is possible to boot without that entry, but updating
the kernel package in that situation can lead to breakage, such as being
unable to find kernel modules, which are essential for functionality such as
wireless connectivity. If you aren't using an SD card, replace
`/dev/mmcblk0p1` with the appropriate device path.

``` /dev/mmcblk0p1 /boot vfat defaults 0 0 ```

### System time

Several of the ARM devices supported by Void Linux don't have battery
powered real time clocks (RTCs), which means they won't keep track of time
once powered off. This issue can present itself as HTTPS errors when
browsing the Web or using the package manager. It is possible to set the
time manually using the [date(1)](https://man.voidlinux.org/date.1)
utility. In order to fix this issue for subsequent boots, install and enable
[an NTP client](../../../config/date-time.md#ntp). Furthermore, it is
possible to install the `fake-hwclock` package, which provides the
`fake-hwclock` service.
[fake-hwclock(8)](https://man.voidlinux.org/fake-hwclock.8) periodically
stores the current time in a configuration file and restores it at boot,
leading to a better initial approximation of the current time, even without
a network connection.

**Warning**: Images from before 2020-03-16 might have an issue where the
installation of the `chrony` package, the default NTP daemon, is incomplete, and
the system will be missing the `chrony` user. This can be checked in the output
of the [getent(1)](https://man.voidlinux.org/getent.1) command, which will be
empty if it doesn't exist:

``` $ getent group chrony chrony:x:997 ```

In order to fix this, it is necessary to reconfigure the `chrony` package
using [xbps-reconfigure(1)](https://man.voidlinux.org/xbps-reconfigure).

### Graphical session

The `xf86-video-fbturbo` package ships a modified version of the [DDX Xorg
driver](../../../config/graphical-session/xorg.md#ddx) found in the
`xf86-video-fbdev` package, which is optimized for ARM devices. This can be
used for devices which lack more specific drivers.
</code></pre>
<h1><a class="header" href="#supported-platforms" id="supported-platforms">Supported Platforms</a></h1>
<h2><a class="header" href="#raspberry-pi" id="raspberry-pi">Raspberry Pi</a></h2>
<p>The <code>rpi-kernel</code> packages for all Raspberry Pi variants are built from the
Raspberry Pi Foundation's kernel tree, which should enable all special
functionality that isn't available with mainline kernels. The RPi kernel
packages also have their own header packages, <code>rpi-kernel-headers</code>. These
packages should be installed if you want to use any DKMS packages. Void
ships <code>rpi-base</code> meta-packages that install the relevant <code>rpi-kernel</code> and
<code>rpi-firmware</code> packages. Together, these packages enable Wi-Fi and Bluetooth
functionality.</p>
<p>The <a href="installation/guides/arm-devices/../../../config/kernel.html#cmdline">command line</a> parameters passed to
the kernel are in the <code>rootfs/boot/cmdline.txt</code> file. Some of the relevant
parameters are documented in the <a href="https://www.raspberrypi.org/documentation/configuration/cmdline-txt.md">official
documentation</a>.</p>
<h3><a class="header" href="#raspberry-pi-3-32-bit-or-64-bit" id="raspberry-pi-3-32-bit-or-64-bit">Raspberry Pi 3: 32-bit or 64-bit</a></h3>
<p>It is possible to run the RPi 2 images on an RPi 3, as the RPi 3's CPU
supports both the Armv8 and Armv7 instruction sets. The difference between
these images is that the RPi 2 provides a 32-bit system with packages from
the Void <code>armv7l</code> repositories, while the RPi 3 image provides a 64-bit
system with packages from the Void <code>aarch64</code> repositories.</p>
<h3><a class="header" href="#enabling-hardware-rng-device" id="enabling-hardware-rng-device">Enabling hardware RNG device</a></h3>
<p>By default, the
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">HWRNG</a>
device is not used by the system, which may result in the random devices
taking long to seed on boot. This can be annoying if you want to start
<code>sshd</code> and expect to be able to connect immediately.</p>
<p>In order to fix this, install the <code>rng-tools</code> package and
<a href="installation/guides/arm-devices/../../../config/services/index.html#enabling-services">enable</a> the <code>rngd</code>
service, which uses the <code>/dev/hwrng</code> device to seed <code>/dev/random</code>.</p>
<h3><a class="header" href="#graphical-session" id="graphical-session">Graphical session</a></h3>
<p>The <code>mesa-dri</code> package contains drivers for all the Raspberry Pi variants,
and can be used with the <a href="installation/guides/arm-devices/../../../config/graphical-session/xorg.html#modesetting">modesetting Xorg
driver</a> or
<a href="installation/guides/arm-devices/../../../config/graphical-session/wayland.html">Wayland</a>.</p>
<h3><a class="header" href="#hardware" id="hardware">Hardware</a></h3>
<p>More configuration information can be found in the Raspberry Pi Foundation's
<a href="https://www.raspberrypi.org/documentation/configuration/">official
documentation</a>.
The <code>raspi-config</code> utility isn't available for Void Linux, so editing the
<code>/boot/config.txt</code> file is usually required.</p>
<h4><a class="header" href="#audio" id="audio">Audio</a></h4>
<p>To enable the soundchip, add <code>dtparam=audio=on</code> to <code>/boot/config.txt</code>.</p>
<h4><a class="header" href="#serial" id="serial">Serial</a></h4>
<p>To enable serial console logins,
<a href="installation/guides/arm-devices/../../../config/services/index.html#enabling-services">enable</a> the
<code>agetty-ttyAMA0</code> service. See
<a href="https://man.voidlinux.org/securetty.5">securetty(5)</a> for interfaces that
allow root login. For configuration of the serial port at startup, refer to
the kernel command line in <code>/boot/cmdline.txt</code> - in particular, the
<code>console=ttyAMA0,115200</code> parameter.</p>
<h3><a class="header" href="#i2c" id="i2c">I2C</a></h3>
<p>To enable <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a>, add
<code>device_tree_param=i2c_arm=on</code> to <code>/boot/config.txt</code>, and
<code>bcm2708.vc_i2c_override=1</code> to <code>/boot/cmdline.txt</code>. Then create a
<a href="https://man.voidlinux.org/modules-load.8">modules-load(8)</a> <code>.conf</code> file
with the following content:</p>
<p><code>i2c-dev</code></p>
<p>Finally, install the <code>i2c-tools</code> package and use
<a href="https://man.voidlinux.org/i2cdetect.8">i2cdetect(8)</a> to verify your
configuration. It should show:</p>
<pre><code>$ i2cdetect -l
i2c-1i2c          bcm2835 I2C adapter                 I2C adapter
</code></pre>
<h3><a class="header" href="#memory-cgroup" id="memory-cgroup">Memory cgroup</a></h3>
<p>The kernel from the <code>rpi-kernel</code> package <a href="https://github.com/raspberrypi/linux/commit/9b0efcc1ec497b2985c6aaa60cd97f0d2d96d203#diff-f1d702fa7c504a2b38b30ce6bb098744">disables the memory cgroup by
default</a>.</p>
<p>This breaks workloads which use containers. Therefore, if you want to use
containers on your Raspberry Pi, you need to enable memory cgroups by adding
<code>cgroup_enable=memory</code> to <code>/boot/cmdline.txt</code>.</p>
<h1><a class="header" href="#musl" id="musl">musl</a></h1>
<p><a href="https://musl.libc.org/">musl</a> is a libc implementation which strives to be
lightweight, fast, simple, and correct.</p>
<p>Void officially supports musl by using it in its codebase for all target
platforms (although binary packages are not available for
i686). Additionally, all compatible packages in our official repositories
are available with musl-linked binaries in addition to their glibc
counterparts.</p>
<p>Currently, there are nonfree and debug sub-repositories for musl, but no
multilib sub-repo.</p>
<h2><a class="header" href="#incompatible-software" id="incompatible-software">Incompatible software</a></h2>
<p>musl practices very strict and minimal standard compliance. Many commonly
used platform-specific extensions are not present. Because of this, it is
common for software to need modification to compile and/or function
properly. Void developers work to patch such software and hopefully get
portability/correctness changes accepted into the upstream projects.</p>
<p>Proprietary software rarely supports non-glibc libc implementations,
although sometimes these applications are available as
<a href="https://flatpak.org/">flatpaks</a>, which provide their own libc in the image.</p>
<h3><a class="header" href="#glibc-chroot" id="glibc-chroot">glibc chroot</a></h3>
<p>Software requiring glibc can be run in a glibc chroot.</p>
<p>Create a directory that will contain the chroot, and install a base system
in it via the <code>base-voidstrap</code> package. If network access is required, copy
<code>/etc/resolv.conf</code> into the chroot; <code>/etc/hosts</code> may need to be copied as
well.</p>
<p>Several directories then need to be mounted as follows:</p>
<pre><code class="language-#mount-tprocnone&lt;chroot_dir&gt;/proc#mount-tsysfsnone">&lt;chroot_dir&gt;/sys # mount --rbind /dev &lt;chroot_dir&gt;/dev # mount --rbind /run
&lt;chroot_dir&gt;/run ```

Use [chroot(1)](https://man.voidlinux.org/chroot.1) to change to the new
root, then run glibc programs as usual. Once you've finished using it,
unmount the chroot using [umount(8)](https://man.voidlinux.org/umount.8).

#### PRoot

An alternative to the above is
[proot(1)](https://man.voidlinux.org/proot.1), a user-space implementation
of chroot, mount --bind, and binfmt_misc. By installing the `proot` package,
unprivileged users can utilize a chroot environment.
</code></pre>
<h1><a class="header" href="#configuration" id="configuration">Configuration</a></h1>
<p>This section and its subsections provide information about configuring your
Void system.</p>
<h1><a class="header" href="#manual-pages" id="manual-pages">Manual Pages</a></h1>
<p>Many Void packages come with manual ('man') pages. The default installation
includes the <a href="https://mandoc.bsd.lv/">mandoc</a> manpage toolset, via the
<code>mdocml</code> package.</p>
<p>The <a href="https://man.voidlinux.org/man.1">man(1)</a> command can be used to show
man pages:</p>
<p><code>$ man chroot</code></p>
<p>Every man page belongs to a particular <em>section</em>:</p>
<ul>
<li>1: User commands (Programs)  - 2: System calls - 3: Library calls - 4:
Special files (devices)  - 5: File formats and configuration files - 6:
Games - 7: Overview, conventions, and miscellaneous - 8: System management
commands</li>
</ul>
<p>Refer to <a href="https://man.voidlinux.org/man-pages.7">man-pages(7)</a> for details.</p>
<p>There are some man pages which have the same name, but are used in different
contexts, and are thus in a different section. You can specify which one to
use by including the section number in the call to <code>man</code>:</p>
<p><code>$ man 1 printf</code></p>
<p><code>man</code> can be configured via
<a href="https://man.voidlinux.org/man.conf.5">man.conf(5)</a>.</p>
<p>The <code>mandoc</code> toolset contains
<a href="https://man.voidlinux.org/apropos.1">apropos(1)</a>, which can be used to
search for manual pages. <code>apropos</code> uses a database that can be generated and
updated with the <a href="https://man.voidlinux.org/makewhatis.8">makewhatis(8)</a>
command:</p>
<pre><code class="language-#makewhatis-a$aproposchrootchroot(1)-runcommandorinteractive">shell with special root directory xbps-uchroot(1) - XBPS utility to chroot
and bind mount with Linux namespaces xbps-uunshare(1) - XBPS utility to
chroot and bind mount with Linux user namespaces chroot(2) - change root
directory ```

The `mdocml` package provides a cron job to update the database daily,
`/etc/cron.daily/makewhatis`. You will need to install a [cron
daemon](./cron.md) for this functionality to be activated.

Development and POSIX manuals are not installed by default, but are
available via the `man-pages-devel` and `man-pages-posix` packages.
</code></pre>
<h1><a class="header" href="#firmware" id="firmware">Firmware</a></h1>
<p>Void provides a number of firmware packages in the repositories. Some
firmware is only available if you have enabled the
<a href="config/../xbps/repositories/index.html#nonfree">nonfree</a> repository.</p>
<h2><a class="header" href="#microcode" id="microcode">Microcode</a></h2>
<p>Microcode is loaded onto the CPU or GPU at boot by the BIOS, but can be
replaced later by the OS itself. An update to microcode can allow a CPU's or
GPU's behavior to be modified to work around certain yet to be discovered
bugs, without the need to replace the hardware.</p>
<h3><a class="header" href="#intel" id="intel">Intel</a></h3>
<p>Install the Intel microcode package, <code>intel-ucode</code>. This package is in the
nonfree repo, which has to be
<a href="config/../xbps/repositories/index.html#nonfree">enabled</a>.  After installing this
package, it is necessary to regenerate your
<a href="config/./kernel.html#kernel-hooks">initramfs</a>. For subsequent updates, the microcode
will be added to the initramfs automatically.</p>
<h3><a class="header" href="#amd" id="amd">AMD</a></h3>
<p>Install the AMD package, <code>linux-firmware-amd</code>, which contains microcode for
both AMD CPUs and GPUs. AMD CPUs and GPUs will automatically load the
microcode, no further configuration required.</p>
<h3><a class="header" href="#verification" id="verification">Verification</a></h3>
<p>The <code>/proc/cpuinfo</code> file has some information under <code>microcode</code> that can be
used to verify the microcode update.</p>
<h2><a class="header" href="#removing-firmware" id="removing-firmware">Removing firmware</a></h2>
<p>By default, <code>linuxX.Y</code> packages and the <code>base-system</code> package install a
number of firmware packages. It is not necessary to remove unused firmware
packages, but if you wish to do so, you can configure XBPS to
<a href="config/../xbps/advanced-usage.html#ignoring-packages">ignore</a> those packages, then
remove them.</p>
<h1><a class="header" href="#locales-and-translations" id="locales-and-translations">Locales and Translations</a></h1>
<p>For a list of currently enabled locales, run</p>
<p><code>$ locale -a</code></p>
<h2><a class="header" href="#enabling-locales" id="enabling-locales">Enabling locales</a></h2>
<p>To enable a certain locale, un-comment or add the relevant lines in
<code>/etc/default/libc-locales</code> and <a href="config/../xbps/index.html">reconfigure</a> the
<code>glibc-locales</code> package.</p>
<h2><a class="header" href="#setting-the-system-locale" id="setting-the-system-locale">Setting the system locale</a></h2>
<p>Set <code>LANG=xxxx</code> in <code>/etc/locale.conf</code>.</p>
<h2><a class="header" href="#application-locale" id="application-locale">Application locale</a></h2>
<p>Some programs have their translations in a separate package that must be
installed in order to use them. You can
<a href="config/../xbps/index.html#finding-files-and-packages">search</a> for the desired
language (e.g. &quot;german&quot; or &quot;portuguese&quot;) in the package repositories and
install the packages relevant to the applications you use. An especially
relevant case is when installing individual packages from the LibreOffice
suite, such as <code>libreoffice-writer</code>, which require installing at least one
of the <code>libreoffice-i18n-*</code> packages to work properly. This isn't necessary
when installing the <code>libreoffice</code> meta-package, since doing so will install
the most common translation packages.</p>
<h1><a class="header" href="#users-and-groups" id="users-and-groups">Users and Groups</a></h1>
<p>The <a href="https://man.voidlinux.org/useradd.8">useradd(8)</a>,
<a href="https://man.voidlinux.org/userdel.8">userdel(8)</a> and
<a href="https://man.voidlinux.org/usermod.8">usermod(8)</a> commands are used to add,
delete and modify users respectively. The
<a href="https://man.voidlinux.org/passwd.1">passwd(1)</a> command is used to change
passwords.</p>
<p>The <a href="https://man.voidlinux.org/groupadd.8">groupadd(8)</a>,
<a href="https://man.voidlinux.org/groupdel.8">groupdel(8)</a> and
<a href="https://man.voidlinux.org/groupmod.8">groupmod(8)</a> commands are used to
add, delete and modify groups respectively. The
<a href="https://man.voidlinux.org/groups.1">groups(1)</a> command lists all groups a
user belongs to.</p>
<h2><a class="header" href="#default-shell" id="default-shell">Default shell</a></h2>
<p>The default shell for a user can be changed with
<a href="https://man.voidlinux.org/chsh.1">chsh(1)</a>:</p>
<p><code>$ chsh -s &lt;shell&gt; &lt;user_name&gt;</code></p>
<p><code>&lt;shell&gt;</code> must be the path to the shell as specified by <code>/etc/shells</code> or the
output of <code>chsh -l</code>, which provides a list of installed shells.</p>
<h2><a class="header" href="#sudo" id="sudo">sudo</a></h2>
<p><a href="https://man.voidlinux.org/sudo.8">sudo(8)</a> is installed by default, but
might not be configured appropriately for your needs. It is only necessary
to configure sudo if you wish to use it.</p>
<p>Use <a href="https://man.voidlinux.org/visudo.8">visudo(8)</a> as root to edit the
<a href="https://man.voidlinux.org/sudoers.5">sudoers(5)</a> file.</p>
<p>To create a superuser, uncomment the line</p>
<p><code>#%wheel ALL=(ALL) ALL</code></p>
<p>and add users to the <code>wheel</code> group.</p>
<h2><a class="header" href="#default-groups" id="default-groups">Default Groups</a></h2>
<p>Void Linux defines a number of groups by default.</p>
<table><thead><tr><th>Group</th><th>Description</th></tr></thead><tbody>
<tr><td><code>root</code></td><td>Complete access to the system.</td></tr>
<tr><td><code>bin</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>sys</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>kmem</code></td><td>Ability to read from <code>/dev/mem</code> and <code>/dev/port</code>.</td></tr>
<tr><td><code>wheel</code></td><td>Elevated privileges for specific system administration tasks.</td></tr>
<tr><td><code>tty</code></td><td>Access to TTY-like devices:</td></tr>
<tr><td></td><td><code>/dev/tty*</code>, <code>/dev/pts*</code>, <code>/dev/vcs*</code>.</td></tr>
<tr><td><code>tape</code></td><td>Access to tape devices.</td></tr>
<tr><td><code>daemon</code></td><td>System daemons that need to write to files on disk.</td></tr>
<tr><td><code>floppy</code></td><td>Access to floppy drives.</td></tr>
<tr><td><code>disk</code></td><td>Raw access to <code>/dev/sd*</code> and <code>/dev/loop*</code>.</td></tr>
<tr><td><code>lp</code></td><td>Access to printers.</td></tr>
<tr><td><code>dialout</code></td><td>Access to serial ports.</td></tr>
<tr><td><code>audio</code></td><td>Access to audio devices.</td></tr>
<tr><td><code>video</code></td><td>Access to video devices.</td></tr>
<tr><td><code>utmp</code></td><td>Ability to write to <code>/var/run/utmp</code>, <code>/var/log/wtmp</code></td></tr>
<tr><td></td><td>and <code>/var/log/btmp</code>.</td></tr>
<tr><td><code>adm</code></td><td>Unused - present for historical reasons. This group was</td></tr>
<tr><td></td><td>traditionally used for system monitoring, such as viewing</td></tr>
<tr><td></td><td>files in <code>/var/log</code>.</td></tr>
<tr><td><code>cdrom</code></td><td>Access to CD devices.</td></tr>
<tr><td><code>optical</code></td><td>Access to DVD/CD-RW devices.</td></tr>
<tr><td><code>mail</code></td><td>Used by some mail packages, e.g. <code>dma</code>.</td></tr>
<tr><td><code>storage</code></td><td>Access to removable storage devices.</td></tr>
<tr><td><code>scanner</code></td><td>Ability to access scanners.</td></tr>
<tr><td><code>network</code></td><td>Unused - present for historical reasons.</td></tr>
<tr><td><code>kvm</code></td><td>Ability to use KVM for virtual machines, e.g. via QEMU.</td></tr>
<tr><td><code>input</code></td><td>Access to input devices: <code>/dev/mouse*</code>, <code>/dev/event*</code>.</td></tr>
<tr><td><code>nogroup</code></td><td>System daemons that don't need to own any files.</td></tr>
<tr><td><code>users</code></td><td>Ordinary users.</td></tr>
<tr><td><code>xbuilder</code></td><td>To use xbps-uchroot(1) with <code>xbps-src</code>.</td></tr>
</tbody></table>
<h1><a class="header" href="#services-and-daemons---runit" id="services-and-daemons---runit">Services and Daemons - runit</a></h1>
<p>Void uses the <a href="https://man.voidlinux.org/runit.8">runit(8)</a> supervision
suite to run system services and daemons.</p>
<p>Some advantages of using runit include:</p>
<ul>
<li>a small code base, making it easier to audit for bugs and security issues.</li>
<li>each service is given a clean process state, regardless of how the service was
started or restarted: it will be started with the same environment, resource
limits, open file descriptors, and controlling terminals.</li>
<li>a reliable logging facility for services, where the log service stays up as
long as the relevant service is running and possibly writing to the log.</li>
</ul>
<p>If you don't need a program to be running constantly, but would like it to
run at regular intervals, you might like to consider using a <a href="config/services/../cron.html">cron
daemon</a>.</p>
<h2><a class="header" href="#section-contents-1" id="section-contents-1">Section Contents</a></h2>
<ul>
<li><a href="config/services/./user-services.html">Per-User Services</a>  - <a href="config/services/./logging.html">Logging</a></li>
</ul>
<h2><a class="header" href="#service-directories" id="service-directories">Service Directories</a></h2>
<p>Each service managed by runit has an associated <em>service directory</em>.</p>
<p>A service directory requires only one file: an executable named <code>run</code>, which
is expected to exec a process in the foreground.</p>
<p>Optionally, a service directory may contain:</p>
<ul>
<li>an executable named <code>check</code>, which will be run to check whether the service is
up and available; it's considered available if <code>check</code> exits with 0.</li>
<li>an executable named <code>finish</code>, which will be run on shutdown/process stop.</li>
<li>a <code>conf</code> file; this can contain environment variables to be sourced and
referenced in <code>run</code>.</li>
<li>a directory named <code>log</code>; a pipe will be opened from the output of the <code>run</code>
process in the service directory to the input of the <code>run</code> process in the
<code>log</code> directory.</li>
</ul>
<p>When a new service is created, a <code>supervise</code> folder will be automatically
created on the first run.</p>
<h3><a class="header" href="#configuring-services" id="configuring-services">Configuring Services</a></h3>
<p>Most services can take configuration options set by a <code>conf</code> file in the
service directory. This allows service customization without modifying the
service directory provided by the relevant package.</p>
<p>Check the service file for how to pass configuration parameters. A few
services have a field like <code>OPTS=&quot;--value ...&quot;</code> in their <code>conf</code> file.</p>
<p>To make more complex customizations, you should <a href="config/services/index.html#editing-services">edit the
service</a>.</p>
<h3><a class="header" href="#editing-services" id="editing-services">Editing Services</a></h3>
<p>To edit a service, first copy its service directory to a different directory
name. Otherwise, <a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a>
can overwrite the service directory. Then, edit the new service file as
needed.  Finally, the old service should be stopped and disabled, and the
new one should be started.</p>
<h2><a class="header" href="#managing-services" id="managing-services">Managing Services</a></h2>
<h3><a class="header" href="#runsvdirs" id="runsvdirs">Runsvdirs</a></h3>
<p>A <strong>runsvdir</strong> is a directory in <code>/etc/runit/runsvdir</code> containing enabled
services in the form of symlinks to service directories. On a running
system, the current runsvdir is accessible via the <code>/var/service</code> symlink.</p>
<p>The <code>runit-void</code> package comes with two runsvdirs, <code>single</code> and <code>default</code>:</p>
<ul>
<li><code>single</code> just runs <a href="https://man.voidlinux.org/sulogin.8">sulogin(8)</a> and the
necessary steps to rescue your system.</li>
<li><code>default</code> is the default runsvdir on a running system, unless <a href="config/services/index.html#booting-a-different-runsvdir">specified
otherwise by the kernel command line</a>.</li>
</ul>
<p>Additional runsvdirs can be created in <code>/etc/runit/runsvdir/</code>.</p>
<p>See <a href="https://man.voidlinux.org/runsvdir.8">runsvdir(8)</a> and
<a href="https://man.voidlinux.org/runsvchdir.8">runsvchdir(8)</a> for further
information.</p>
<h4><a class="header" href="#booting-a-different-runsvdir" id="booting-a-different-runsvdir">Booting A Different runsvdir</a></h4>
<p>To boot a runsvdir other than <code>default</code>, the name of the desired runsvdir
can be added to the <a href="config/services/../kernel.html#cmdline">kernel command-line</a>. As an
example, adding <code>single</code> to the kernel command line will boot the <code>single</code>
runsvdir.</p>
<h3><a class="header" href="#basic-usage" id="basic-usage">Basic Usage</a></h3>
<p>To start, stop, restart or get the status of a service:</p>
<pre><code class="language-#svup&lt;services&gt;#svdown&lt;services&gt;#svrestart&lt;services&gt;#sv">status &lt;services&gt; ```

The `&lt;services&gt;` placeholder can be:

- Service names (service directory names) inside the `/var/service/`
directory.  - The full paths to the services.

For example, the following commands show the status of a specific service
and of all enabled services:

``` # sv status dhcpcd # sv status /var/service/* ```

See [sv(8)](https://man.voidlinux.org/sv.8) for further information.

#### Enabling Services

Void Linux provides service directories for most daemons in `/etc/sv/`.

To enable a service on a booted system, create a symlink to the service
directory in `/var/service/`:

``` # ln -s /etc/sv/&lt;service&gt; /var/service/ ```

If the system is not currently running, the service can be linked directly
into the `default` [runsvdir](#runsvdirs):

``` # ln -s /etc/sv/&lt;service&gt; /etc/runit/runsvdir/default/ ```

This will automatically start the service. Once a service is linked it will
always start on boot and restart if it stops, unless administratively
downed.

To prevent a service from starting at boot while allowing runit to manage
it, create a file named `down` in its service directory:

``` # touch /etc/sv/&lt;service&gt;/down ```

The `down` file mechanism also makes it possible to disable services that
are enabled by default, such as the
[agetty(8)](https://man.voidlinux.org/agetty.8)  services for ttys 1 to
6. This way, package updates which affect these services - in this case, the
`runit-void` package - won't re-enable them.

#### Disabling Services

To disable a service, remove the symlink from the running runsvdir:

``` # rm /var/service/&lt;service&gt; ```

Or, for example, from the `default` runsvdir, if either the specific
runsvdir, or the system, is not currently running:

``` # rm /etc/runit/runsvdir/default/&lt;service&gt; ```

#### Testing Services

To check if a service is working correctly when started by the service
supervisor, run it once before fully enabling it:

``` # touch /etc/sv/&lt;service&gt;/down # ln -s /etc/sv/&lt;service&gt; /var/service/ #
sv once &lt;service&gt; ```

If everything works, remove the `down` file to enable the service.
</code></pre>
<h1><a class="header" href="#per-user-services" id="per-user-services">Per-User Services</a></h1>
<p>Sometimes it can be nice to have user-specific runit services. For example,
you might want to open an ssh tunnel as the current user, run a virtual
machine, or regularly run daemons on your behalf. The most common way to do
this is to create a system-level service that runs
<a href="https://man.voidlinux.org/runsvdir.8">runsvdir(8)</a> as your user, in order
to start and monitor the services in a personal services directory.</p>
<p>For example, you could create a service called <code>/etc/sv/runsvdir-&lt;username&gt;</code>
with the following <code>run</code> script:</p>
<pre><code class="language-#!/bin/sh">
export USER=&quot;&lt;username&gt;&quot; export HOME=&quot;/home/&lt;username&gt;&quot;

groups=&quot;$(id -Gn &quot;$USER&quot; | tr ' ' ':')&quot; svdir=&quot;$HOME/service&quot;

exec chpst -u &quot;$USER:$groups&quot; runsvdir &quot;$svdir&quot; ```

In this example [chpst(8)](https://man.voidlinux.org/chpst.8) is used to
start a new [runsvdir(8)](https://man.voidlinux.org/runsvdir.8) process as
the specified user. [chpst(8)](https://man.voidlinux.org/chpst.8) does not
read groups on its own, but expects the user to list all required groups
separated by a `:`. The `id` and `tr` pipe is used to create a list of all
the user's groups in a way [chpst(8)](https://man.voidlinux.org/chpst.8)
understands it. Note that we export `$USER` and `$HOME` because some user
services may not work without them.

The user can then create new services or symlinks to them in the
`/home/&lt;username&gt;/service` directory. To control the services using the
[sv(8)](https://man.voidlinux.org/sv.8) command, the user can specify the
services by path, or by name if the `SVDIR` environment variable is set to
the user's services directory. This is shown in the following examples:

``` $ sv status ~/service/* run: /home/duncan/service/gpg-agent: (pid 901)
33102s run: /home/duncan/service/ssh-agent: (pid 900) 33102s $
SVDIR=~/service sv restart gpg-agent ok: run: gpg-agent: (pid 19818) 0s ```

It may be convenient to export the `SVDIR=~/service` variable in your shell
profile.
</code></pre>
<h1><a class="header" href="#logging" id="logging">Logging</a></h1>
<h2><a class="header" href="#syslog" id="syslog">Syslog</a></h2>
<p>The default installation comes with no syslog daemon. However, there are
syslog implementations available in the Void repositories.</p>
<h3><a class="header" href="#socklog" id="socklog">Socklog</a></h3>
<p><a href="https://man.voidlinux.org/socklog.8">socklog(8)</a> is a syslog implementation
from the author of <a href="https://man.voidlinux.org/runit.8">runit(8)</a>. Use
socklog if you're not sure which syslog implementation to use. To use it,
install the <code>socklog-void</code> package, and enable the <code>socklog-unix</code> and
<code>nanoklogd</code> services.</p>
<p>The logs are saved in sub-directories of <code>/var/log/socklog/</code>, and
<code>svlogtail</code> can be used to help access them conveniently.</p>
<p>The ability to read logs is limited to <code>root</code> and users who are part of the
<code>socklog</code> group.</p>
<h3><a class="header" href="#other-syslog-daemons" id="other-syslog-daemons">Other syslog daemons</a></h3>
<p>The Void repositories also include packages for <code>rsyslog</code> and <code>metalog</code>.</p>
<h1><a class="header" href="#rcconf-rclocal-and-rcshutdown" id="rcconf-rclocal-and-rcshutdown">rc.conf, rc.local and rc.shutdown</a></h1>
<p>The files <code>/etc/rc.conf</code>, <code>/etc/rc.local</code> and <code>/etc/rc.shutdown</code> can be used
to configure certain parts of your Void system. <code>rc.conf</code> is often
configured by <code>void-installer</code>.</p>
<h2><a class="header" href="#rcconf" id="rcconf">rc.conf</a></h2>
<p>Sourced in runit stages 1 and 3. This file can be used to set variables,
including the following:</p>
<h3><a class="header" href="#keymap" id="keymap">KEYMAP</a></h3>
<p>Specifies which keymap to use for the Linux console. Available keymaps are
listed in <code>/usr/share/kbd/keymaps</code>. For example:</p>
<p><code>KEYMAP=fr</code></p>
<p>For further details, refer to
<a href="https://man.voidlinux.org/loadkeys.1">loadkeys(1)</a>.</p>
<h3><a class="header" href="#hardwareclock" id="hardwareclock">HARDWARECLOCK</a></h3>
<p>Specifies whether the hardware clock is set to UTC or local time.</p>
<p>By default this is set to <code>utc</code>. However, Windows sets the hardware clock to
local time, so if you are dual-booting with Windows, you need to either
configure Windows to use UTC, or set this variable to <code>localtime</code>.</p>
<p>For further details, refer to
<a href="https://man.voidlinux.org/hwclock.8">hwclock(8)</a>.</p>
<h3><a class="header" href="#font" id="font">FONT</a></h3>
<p>Specifies which font to use for the Linux console. Available fonts are
listed in <code>/usr/share/kbd/consolefonts</code>. For example:</p>
<p><code>FONT=eurlatgr</code></p>
<p>For further details, refer to
<a href="https://man.voidlinux.org/setfont.1">setfont(1)</a>.</p>
<h2><a class="header" href="#rclocal" id="rclocal">rc.local</a></h2>
<p>Sourced in runit stage 2. A shell script which can be used to specify
configuration to be done prior to login.</p>
<h2><a class="header" href="#rcshutdown" id="rcshutdown">rc.shutdown</a></h2>
<p>Sourced in runit stage 3. A shell script which can be used to specify tasks
to be done during shutdown.</p>
<h1><a class="header" href="#cron" id="cron">Cron</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Cron">cron</a> is a daemon for running programs
at regular intervals. The programs and intervals are specified in a
<code>crontab</code> file, which can be edited with
<a href="https://man.voidlinux.org/crontab.1">crontab(1)</a>.  Running <code>crontab -e</code> as
the superuser will edit the system crontab; otherwise, it will edit the
crontab for the current user.</p>
<p>By default, a cron daemon is not installed. However, multiple cron
implementations are available, including
<a href="https://github.com/cronie-crond/cronie/">cronie</a>,
<a href="http://www.jimpryor.net/linux/dcron.html">dcron</a>,
<a href="http://fcron.free.fr/">fcron</a> and more.</p>
<p>Once you have chosen and installed an implementation,
<a href="config/./services/index.html#enabling-services">enable</a> the <code>crond</code> service, which
is a symlink to the actual service (e.g. <code>dcron</code>). If you install several
implementations, you can choose which one to use via
<a href="https://man.voidlinux.org/xbps-alternatives.1">xbps-alternatives(1)</a>; this
will alter the <code>crond</code> symlink appropriately. Implementation documentation
will be available in <a href="https://man.voidlinux.org/crond.8">crond(8)</a>.</p>
<p>As an alternative to the standard cron implementations, you can use
<a href="https://man.voidlinux.org/snooze.1">snooze(1)</a> together with the
<code>snooze-hourly</code>, <code>snooze-daily</code>, <code>snooze-weekly</code> and <code>snooze-monthly</code>
services, which are provided by the <code>snooze</code> package for this purpose. Each
of these services execute scripts in the respective <code>/etc/cron.*</code>
directories.</p>
<h1><a class="header" href="#solid-state-drives" id="solid-state-drives">Solid State Drives</a></h1>
<p>Post installation, you will need to enable TRIM for solid state drives. You
can check which devices allow TRIM by running:</p>
<p><code>$ lsblk --discard</code></p>
<p>If the DISC-GRAN (discard granularity) and DISC-MAX (discard maximum bytes)
columns are non-zero, that means the block device has TRIM support. If your
solid state drive partition does not show TRIM support, please verify that
you chose a file system with TRIM support (ext4, Btrfs, F2FS, etc.). Note
that F2FS requires kernel 4.19 or above to support TRIM.</p>
<p>To run TRIM one-shot, you can run
<a href="https://man.voidlinux.org/fstrim.8"><code>fstrim(8)</code></a> manually. For example, if
your / directory is on an SSD:</p>
<p><code># fstrim /</code></p>
<p>To automate running TRIM, use cron or add the <code>discard</code> option to
<code>/etc/fstab</code>.</p>
<h2><a class="header" href="#periodic-trim-with-cron" id="periodic-trim-with-cron">Periodic TRIM with cron</a></h2>
<p>Add the following lines to <code>/etc/cron.daily/fstrim</code>:</p>
<pre><code class="language-#!/bin/sh">
fstrim / ```

Finally, make the script executable:

``` # chmod u+x /etc/cron.daily/fstrim ```

## Continuous TRIM with fstab discard

You can use either continuous or periodic TRIM, but usage of continuous TRIM
is discouraged if you have an SSD that doesn't handle NCQ correctly. Refer
to the kernel
[blacklist](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ata/libata-core.c?h=v5.8&amp;id=bcf876870b95592b52519ed4aafcf9d95999bc9c#n3774).

Edit `/etc/fstab` and add the `discard` option to block devices that need
TRIM.

For example, if `/dev/sda1` was an SSD partition, formatted as ext4, and
mounted at `/`:

</code></pre>
<p>/dev/sda1  /           ext4  defaults,discard   0  1</p>
<pre><code>
## LVM

To enable TRIM for LVM's commands (`lvremove`, `lvreduce`, etc.), open
`/etc/lvm/lvm.conf`, uncomment the `issue_discards` option, and set it to
`1`:

``` issue_discards=1 ```

## LUKS

**Warning**: Before enabling discard for your LUKS partition, please be aware of
the [security
implications](https://wiki.archlinux.org/index.php/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)).

To open an encrypted LUKS device and allow discards to pass through, open
the device with the `--allow-discards` option:

``` # cryptsetup luksOpen --allow-discards /dev/sdaX luks ```

### Non-root devices

Edit `/etc/crypttab` and set the `discard` option for devices on the
SSD. For example, if you have a LUKS device with the name `externaldrive1`,
device `/dev/sdb2`, and password `none`:

</code></pre>
<p>externaldrive1  /dev/sdb2   none    luks,discard</p>
<pre><code>
### Root devices

If your root device is on LUKS, add `rd.luks.allow-discards` to
`CMDLINE_LINUX_DEFAULT`. In the case of GRUB, edit `/etc/default/grub`:

``` GRUB_CMDLINE_LINUX_DEFAULT=&quot;rd.luks.allow-discards&quot; ```

### Verifying configuration

To verify that you have configured TRIM correctly for LUKS, run:

``` # dmsetup table /dev/mapper/crypt_dev --showkeys ```

If this command output contains the string `allow_discards`, you have
successfully enabled TRIM on your LUKS device.

## ZFS

Before running `trim` on a ZFS pool, ensure that all devices in the pool
support it:

``` # zpool get all | grep trim ```

If the pool allows `autotrim` (set `off` by default), you can `trim` the
pool periodically or automatically. To one-shot `trim` `yourpoolname`:

``` # zpool trim yourpoolname ```

### Periodic TRIM

Add the following lines to `/etc/cron.daily/ztrim`:

``` #!/bin/sh zpool trim yourpoolname ```

Finally, make the script executable:

``` # chmod u+x /etc/cron.daily/ztrim ```

### Autotrim

To set autotrim for `yourpoolname`, run:

``` # zpool set autotrim=on yourpoolname ```
</code></pre>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>There are several ways you can make your installation more secure. This
section explores some of them.</p>
<h2><a class="header" href="#section-contents-2" id="section-contents-2">Section Contents</a></h2>
<ul>
<li><a href="config/security/./apparmor.html">AppArmor</a></li>
</ul>
<h1><a class="header" href="#apparmor" id="apparmor">AppArmor</a></h1>
<p>AppArmor is a mandatory access control mechanism (like SELinux). It can
constrain programs based on pre-defined or generated policy definitions.</p>
<p>Void ships with some default profiles for several services, such as <code>dhcpcd</code>
and <code>wpa_supplicant</code>. Container runtimes such as LXC and podman integrate
with AppArmor for better security for container payloads.</p>
<p>To use AppArmor on a system, one must:</p>
<ol>
<li>Install the <code>apparmor</code> package.</li>
<li>Set the <code>APPARMOR</code> variable in <code>/etc/default/apparmor</code> to <code>enforce</code> or
<code>complain</code>.</li>
<li>Set <code>apparmor=1 security=apparmor</code> on the kernel commandline.</li>
</ol>
<p>To accomplish the third step, consult <a href="config/security/./../kernel.html#cmdline">the documentation on how to modify
the kernel cmdline</a>.</p>
<h1><a class="header" href="#date-and-time" id="date-and-time">Date and Time</a></h1>
<p>To view your system's current date and time information, as well as make
direct changes to it, use <a href="https://man.voidlinux.org/date.1">date(1)</a>.</p>
<h2><a class="header" href="#timezone-1" id="timezone-1">Timezone</a></h2>
<p>The default system timezone can be set by linking the timezone file to
<code>/etc/localtime</code>:</p>
<p><code># ln -sf /usr/share/zoneinfo/&lt;timezone&gt; /etc/localtime</code></p>
<p>To change the timezone on a per user basis, the <code>TZ</code> variable can be
exported from your shell's profile:</p>
<p><code>export TZ=&lt;timezone&gt;</code></p>
<p>Note that setting the <em>timezone</em> does not set the <em>time</em> (or date); instead,
it simply specifies an offset from
<a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a>, as
described in <a href="https://man.voidlinux.org/timezone.3">timezone(3)</a>.</p>
<h2><a class="header" href="#hardware-clock" id="hardware-clock">Hardware clock</a></h2>
<p>By default, the hardware clock in Void is stored as UTC. Windows does not
use UTC by default, and if you are dual-booting, this will conflict with
Void. You can either change Windows to use UTC, or change Void Linux to use
<code>localtime</code> by setting the <code>HARDWARECLOCK</code> variable in <code>/etc/rc.conf</code>:</p>
<p><code>export HARDWARECLOCK=localtime</code></p>
<p>For more details, see <a href="https://man.voidlinux.org/hwclock.8">hwclock(8)</a>.</p>
<h2><a class="header" href="#ntp" id="ntp">NTP</a></h2>
<p>To maintain accuracy of your system's clock, you can use the <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">Network Time
Protocol</a> (NTP).</p>
<p>Void provides packages for three NTP daemons: NTP, OpenNTPD and Chrony.</p>
<p>Once you have installed an NTP daemon, you can <a href="config/../config/services/index.html#managing-services">enable the
service</a>.</p>
<h3><a class="header" href="#ntp-1" id="ntp-1">NTP</a></h3>
<p>NTP is the official reference implementation of the Network Time Protocol.</p>
<p>The <code>ntp</code> package provides NTP and the <code>isc-ntpd</code> service.</p>
<p>For further information, visit <a href="https://www.ntp.org/">the NTP site</a>.</p>
<h3><a class="header" href="#openntpd" id="openntpd">OpenNTPD</a></h3>
<p>OpenNTPD focuses on providing a secure, lean NTP implementation which &quot;just
works&quot; with reasonable accuracy for a majority of use-cases.</p>
<p>The <code>openntpd</code> package provides OpenNTPD and the <code>openntpd</code> service.</p>
<p>For further information, visit <a href="http://www.openntpd.org/">the OpenNTPD
site</a>.</p>
<h3><a class="header" href="#chrony" id="chrony">Chrony</a></h3>
<p>Chrony is designed to work well in a variety of conditions; it can
synchronize faster and with greater accuracy than NTP.</p>
<p>The <code>chrony</code> package provides Chrony and the <code>chronyd</code> service.</p>
<p>The Chrony site provides <a href="https://chrony.tuxfamily.org/faq.html#_how_does_code_chrony_code_compare_to_code_ntpd_code">a brief overview of its advantages over
NTP</a>,
as well as <a href="https://chrony.tuxfamily.org/comparison.html">a detailed feature comparison between Chrony, NTP and
OpenNTPD</a>.</p>
<h1><a class="header" href="#kernel" id="kernel">Kernel</a></h1>
<h2><a class="header" href="#kernel-series" id="kernel-series">Kernel series</a></h2>
<p>Void Linux provides many kernel series in the default repository. These are
named <code>linux&lt;x&gt;.&lt;y&gt;</code>: for example, <code>linux4.19</code>. You can query for all
available kernel series by running:</p>
<p><code>$ xbps-query --regex -Rs '^linux[0-9.]+-[0-9._]+'</code></p>
<p>The <code>linux</code> meta package, installed by default, depends on one of the kernel
packages, usually the package containing the latest mainline kernel that
works with all DKMS modules. Newer kernels might be available in the
repository, but are not necessarily considered stable enough to be the
default; use these at your own risk. If you wish to use a more recent kernel
and have DKMS modules that you need to build, install the relevant
<code>linux&lt;x&gt;.&lt;y&gt;-headers</code> package, then use
<a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> to
reconfigure the <code>linux&lt;x&gt;.&lt;y&gt;</code> package you installed. This will build the
DKMS modules.</p>
<h2><a class="header" href="#removing-old-kernels" id="removing-old-kernels">Removing old kernels</a></h2>
<p>When updating the kernel, old versions are left behind in case it is
necessary to roll back to an older version. Over time, old kernel versions
can accumulate, consuming disk space and increasing the time taken by DKMS
module updates.  Furthermore, if <code>/boot</code> is a separate partition and fills
up with old kernels, updating can fail or result in incomplete initramfs
filesystems to be generated and result in kernel panics if they are being
booted. Thus, it may be advisable to clean old kernels from time to time.</p>
<p>Removing old kernels is done using the
<a href="https://man.voidlinux.org/vkpurge.8">vkpurge(8)</a> utility. <code>vkpurge</code> comes
pre-installed on every Void Linux system. This utility runs the necessary
<a href="config/kernel.html#kernel-hooks">hooks</a> when removing old kernels. Note that <code>vkpurge</code> does
not remove kernel <em>packages</em>, only particular <em>kernels</em>.</p>
<h2><a class="header" href="#removing-the-default-kernel-series" id="removing-the-default-kernel-series">Removing the default kernel series</a></h2>
<p>If you've installed a kernel package for a series other than the default,
and want to remove the default kernel packages, use
<a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> <code>ignorepkg</code> entries to
<a href="config/../xbps/advanced-usage.html#ignoring-packages">ignore</a> the relevant
<code>linux&lt;x&gt;.&lt;y&gt;</code> and <code>linux&lt;x&gt;.&lt;y&gt;-headers</code> packages. After adding these
entries, you will be able to remove the packages with
<a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a>.</p>
<h2><a class="header" href="#kernel-modules" id="kernel-modules">Kernel modules</a></h2>
<p>Kernel modules are typically drivers for devices or filesystems.</p>
<h3><a class="header" href="#loading-kernel-modules-during-boot" id="loading-kernel-modules-during-boot">Loading kernel modules during boot</a></h3>
<p>Normally the kernel automatically loads required modules, but sometimes it
may be necessary to explicitly specify modules to be loaded during boot.</p>
<p>To load kernel modules during boot, a <code>.conf</code> file like
<code>/etc/modules-load.d/virtio.conf</code> needs to be created with the contents:</p>
<p><code># load virtio-net virtio-net</code></p>
<h3><a class="header" href="#blacklisting-kernel-modules" id="blacklisting-kernel-modules">Blacklisting kernel modules</a></h3>
<p>Blacklisting kernel modules is a method for preventing modules from being
loaded by the kernel. There are two different methods for blacklisting
kernel modules, one for modules loaded by the initramfs and one for modules
loaded after the initramfs process is done. Modules loaded by the initramfs
have to be blacklisted in the initramfs configuration.</p>
<p>To blacklist modules loaded after the initramfs process, create a <code>.conf</code>
file, like <code>/etc/modprobe.d/radeon.conf</code>, with the contents:</p>
<p><code>blacklist radeon</code></p>
<h4><a class="header" href="#blacklisting-modules-in-the-initramfs" id="blacklisting-modules-in-the-initramfs">Blacklisting modules in the initramfs</a></h4>
<p>After making the necessary changes to the configuration files, the initramfs
needs to be <a href="config/kernel.html#kernel-hooks">regenerated</a> for the changes to take effect on
the next boot.</p>
<h5><a class="header" href="#dracut" id="dracut">dracut</a></h5>
<p>Dracut can be configured to not include kernel modules through a
configuration file. To blacklist modules from being included in a dracut
initramfs, create a <code>.conf</code> file, like <code>/etc/dracut.conf.d/radeon.conf</code>,
with the contents:</p>
<p><code>omit_drivers+=&quot; radeon &quot;</code></p>
<h5><a class="header" href="#mkinitcpio" id="mkinitcpio">mkinitcpio</a></h5>
<p>To blacklist modules from being included in a mkinitcpio initramfs a <code>.conf</code>
file needs to be created like <code>/etc/modprobe.d/radeon.conf</code> with the
contents:</p>
<p><code>blacklist radeon</code></p>
<h2><a class="header" href="#kernel-hooks" id="kernel-hooks">Kernel hooks</a></h2>
<p>Void Linux provides directories for kernel hooks in
<code>/etc/kernel.d/{pre-install,post-install,pre-remove,post-remove}</code>.</p>
<p>These hooks are used to update the boot menus for bootloaders like <code>grub</code>,
<code>gummiboot</code> and <code>lilo</code>.</p>
<h3><a class="header" href="#install-hooks" id="install-hooks">Install hooks</a></h3>
<p>The <code>{pre,post}-install</code> hooks are executed by
<a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> when
configuring a Linux kernel, such as building its initramfs. This happens
when a kernel series is installed for the first time or updated, but can
also be run manually:</p>
<p><code># xbps-reconfigure --force linux&lt;x&gt;.&lt;y&gt;</code></p>
<p>If run manually, they serve to apply initramfs configuration changes to the
next boot.</p>
<h3><a class="header" href="#remove-hooks" id="remove-hooks">Remove hooks</a></h3>
<p>The <code>{pre,post}-remove</code> hooks are executed by
<a href="https://man.voidlinux.org/vkpurge.8">vkpurge(8)</a> when removing old kernels.</p>
<h2><a class="header" href="#dynamic-kernel-module-support-dkms" id="dynamic-kernel-module-support-dkms">Dynamic Kernel Module Support (DKMS)</a></h2>
<p>There are kernel modules that are not part of the Linux source tree that are
built at install time using DKMS and <a href="config/kernel.html#kernel-hooks">kernel hooks</a>. The
available modules can be listed by searching for <code>dkms</code> in the package
repositories.</p>
<p>DKMS build logs are available in <code>/var/lib/dkms/</code>.</p>
<h2><a class="header" href="#cmdline" id="cmdline">cmdline</a></h2>
<p>The kernel, the initial RAM disk (initrd) and some system programs can be
configured at boot by kernel command line arguments. The parameters
understood by the kernel are explained in the <a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html">kernel-parameters
documentation</a>
and by <a href="https://man.voidlinux.org/bootparam.7">bootparam(7)</a>. Parameters
understood by dracut can be found in
<a href="https://man.voidlinux.org/dracut.cmdline.7">dracut.cmdline(7)</a>.</p>
<p>Once the system is booted, the current kernel command line parameters can be
found in the <code>/proc/cmdline</code> file. Some system programs can change their
behavior based on the parameters passed in the command line, which is what
happens when <a href="config/./services/index.html#booting-a-different-runsvdir">booting a different
runsvdir</a>, for example.</p>
<p>There are different ways of setting these parameters, some of which are
explained below.</p>
<h3><a class="header" href="#grub" id="grub">GRUB</a></h3>
<p>Kernel command line arguments can be added through the GRUB bootloader by
editing <code>/etc/default/grub</code>, changing the <code>GRUB_CMDLINE_LINUX_DEFAULT</code>
variable and then running <code>update-grub</code>.</p>
<h3><a class="header" href="#dracut-1" id="dracut-1">dracut</a></h3>
<p>Dracut can be configured to add additional command line arguments to the
kernel through a configuration file. The documentation for dracut's
configuration files can be found in
<a href="https://man.voidlinux.org/dracut.conf.5">dracut.conf(5)</a>. To apply these
changes, it is necessary to <a href="config/kernel.html#kernel-hooks">regenerate</a> the initramfs.</p>
<h1><a class="header" href="#power-management" id="power-management">Power Management</a></h1>
<h2><a class="header" href="#acpid" id="acpid">acpid</a></h2>
<p>The <code>acpid</code> service for <a href="https://man.voidlinux.org/acpid.8">acpid(8)</a> is
installed and, if Void was installed from a live image using the local
source, will be enabled by default. ACPI events are handled by
<code>/etc/acpi/handler.sh</code>, which uses <a href="https://man.voidlinux.org/zzz.8">zzz(8)</a>
for suspend-to-RAM events.</p>
<h2><a class="header" href="#elogind" id="elogind">elogind</a></h2>
<p>The <code>elogind</code> service is provided by the <code>elogind</code> package. By default,
<a href="https://man.voidlinux.org/elogind.8">elogind(8)</a> listens for, and
processes, ACPI events related to lid-switch activation and the <em>power</em>,
<em>suspend</em> and <em>hibernate</em> keys. This will conflict with the <code>acpid</code> service
if it is installed and enabled. Either disable <code>acpid</code> when enabling
<code>elogind</code>, or configure <code>elogind</code> to <code>ignore</code> ACPI events in
<a href="https://man.voidlinux.org/logind.conf.5">logind.conf(5)</a>. There are several
configuration options, all starting with the keyword <code>Handle</code>, that should
be set to <code>ignore</code> to avoid interfering with <code>acpid</code>.</p>
<h2><a class="header" href="#power-saving---tlp" id="power-saving---tlp">Power Saving - tlp</a></h2>
<p>Laptop battery life can be extended by using
<a href="https://man.voidlinux.org/tlp.8">tlp(8)</a>. To use it, install the <code>tlp</code>
package, and <a href="config/./services/index.html#enabling-services">enable</a> the <code>tlp</code>
service. Refer to <a href="https://linrunner.de/tlp/">the TLP documentation</a> for
details.</p>
<h1><a class="header" href="#network-1" id="network-1">Network</a></h1>
<p>Network configuration in Void Linux can be done in several ways. The default
installation comes with the <a href="https://man.voidlinux.org/dhcpcd.8">dhcpcd(8)</a>
service enabled.</p>
<h2><a class="header" href="#interface-names" id="interface-names">Interface Names</a></h2>
<p>Newer versions of <a href="https://man.voidlinux.org/udev.7">udev(7)</a> no longer use
the traditional Linux naming scheme for interfaces (<code>eth0</code>, <code>eth0</code>, <code>wlan0</code>,
...).</p>
<p>This behavior can be reverted by adding <code>net.ifnames=0</code> to the <a href="config/network/../kernel.html#cmdline">kernel
cmdline</a>.</p>
<h2><a class="header" href="#static-configuration" id="static-configuration">Static Configuration</a></h2>
<p>A simple way to configure a static network at boot is to add the necessary
<a href="https://man.voidlinux.org/ip.8">ip(8)</a> commands to the <code>/etc/rc.local</code>
file:</p>
<pre><code class="language-iplinksetdeveth0upipaddradd192.168.1.2/24brd+deveth0ip">route add default via 192.168.1.1 ```

## dhcpcd

To run [dhcpcd(8)](https://man.voidlinux.org/dhcpcd.8) on all interfaces,
enable the `dhcpcd` service.

To run `dhcpcd` only on a specific interface, copy the `dhcpcd-eth0` service
and modify it to match your interface:

</code></pre>
<p>$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp3s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
link/ether ff:ff:ff:ff:ff:ff brd ff:ff:ff:f</p>
<h1><a class="header" href="#cp--r-etcsvdhcpcd-eth0-etcsvdhcpcd-enp3s0" id="cp--r-etcsvdhcpcd-eth0-etcsvdhcpcd-enp3s0">cp -R /etc/sv/dhcpcd-eth0 /etc/sv/dhcpcd-enp3s0</a></h1>
<h1><a class="header" href="#sed--i-seth0enp3s0-etcsvdhcpcd-enp3s0run" id="sed--i-seth0enp3s0-etcsvdhcpcd-enp3s0run">sed -i 's/eth0/enp3s0/' /etc/sv/dhcpcd-enp3s0/run</a></h1>
<h1><a class="header" href="#ln--s-etcsvdhcpcd-enp3s0-varservice" id="ln--s-etcsvdhcpcd-enp3s0-varservice">ln -s /etc/sv/dhcpcd-enp3s0 /var/service/</a></h1>
<pre><code>
For more information on configuring `dhcpcd`, refer to
[dhcpcd.conf(5)](https://man.voidlinux.org/dhcpcd.conf.5)

## Wireless

Before using wireless networking, use
[rfkill(8)](https://man.voidlinux.org/rfkill.8) to check whether the
relevant interfaces are soft- or hard-blocked.

Void provides several ways to connect to wireless networks:

- [wpa_supplicant](./wpa_supplicant.md)  - [iwd](./iwd.md)  -
[NetworkManager](./networkmanager.md)  - [ConnMan](./connman.md)
</code></pre>
<h1><a class="header" href="#firewalls" id="firewalls">Firewalls</a></h1>
<h2><a class="header" href="#iptables" id="iptables">iptables</a></h2>
<p>By default, the <code>iptables</code> package is installed on the base system. It
provides
<a href="https://man.voidlinux.org/iptables.8">iptables(8)/ip6tables(8)</a>. The
related services use the <code>/etc/iptables/iptables.rules</code> and
<code>/etc/iptables/ip6tables.rules</code> ruleset files, which must be created by the
system administrator.</p>
<p>Two example rulesets are provided in the <code>/etc/iptables</code> directory:
<code>empty.rules</code> and <code>simple_firewall.rules</code>.</p>
<h3><a class="header" href="#applying-the-rules-at-boot" id="applying-the-rules-at-boot">Applying the rules at boot</a></h3>
<p>To apply iptables rules at runit stage 1, install the <code>runit-iptables</code>
package.  This adds a core-service which restores the <code>iptables.rules</code> and
<code>ip6tables.rules</code> rulesets.</p>
<p>Alternatively, to apply these rules at stage 2, add the following to
<code>/etc/rc.local</code>:</p>
<pre><code>if [ -e /etc/iptables/iptables.rules ]; then
  iptables-restore /etc/iptables/iptables.rules
fi

if [ -e /etc/iptables/ip6tables.rules ]; then
  ip6tables-restore /etc/iptables/ip6tables.rules
fi
</code></pre>
<p>After rebooting, check the active firewall rules:</p>
<p><code># iptables -L # ip6tables -L</code></p>
<h3><a class="header" href="#applying-the-rules-at-runtime" id="applying-the-rules-at-runtime">Applying the rules at runtime</a></h3>
<p><code>iptables</code> comes with two runit services, <code>iptables</code> and <code>ip6tables</code>, to
quickly flush or restore the <code>iptables.rules</code> and <code>ip6tables.rules</code>
rulesets. Once these services are
<a href="config/network/../services/index.html#enabling-services">enabled</a>, you can flush the
rulesets by downing the relevant service, e.g.:</p>
<p><code># sv down iptables</code></p>
<p>and restore them by upping the relevant service, e.g.:</p>
<p><code># sv up ip6tables</code></p>
<h2><a class="header" href="#nftables" id="nftables">nftables</a></h2>
<p><code>nftables</code> replaces <code>iptables</code>, <code>ip6tables</code>, <code>arptables</code> and <code>ebtables</code>
(collectively referred to as <code>xtables</code>). The <a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">nftables
wiki</a> describes
<a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_differences_with_iptables">the main
differences</a>
from the <code>iptables</code> toolset.</p>
<p>To use <code>nftables</code>, install the <code>nftables</code> package, which provides
<a href="https://man.voidlinux.org/nft.8">nft(8)</a>. It also provides
<a href="https://man.voidlinux.org/iptables-translate.8">iptables-translate(8)/ip6tables-translate(8)</a>
and
<a href="https://man.voidlinux.org/iptables-restore-translate.8">iptables-restore-translate(8)/ip6tables-restore-translate(8)</a>,
which convert <code>iptables</code> rules to <code>nftables</code> rules.</p>
<h3><a class="header" href="#applying-the-rules-at-boot-1" id="applying-the-rules-at-boot-1">Applying the rules at boot</a></h3>
<p>To apply nftables rules at runit stage 1, install the <code>runit-nftables</code>
package.  This adds a core-service which restores the ruleset in
<code>/etc/nftables.conf</code>.</p>
<h3><a class="header" href="#applying-the-rules-at-runtime-1" id="applying-the-rules-at-runtime-1">Applying the rules at runtime</a></h3>
<p>The <code>nftables</code> package provides the <code>nftables</code> service, which uses rules
from <code>/etc/nftables.conf</code>. Once you
<a href="config/network/../services/index.html#enabling-service">enable</a>  the <code>nftables</code> service, to
load the rules, run:</p>
<p><code># sv up nftables</code></p>
<p>To flush the rules, run:</p>
<p><code># sv down nftables</code></p>
<h1><a class="header" href="#wpa_supplicant" id="wpa_supplicant">wpa_supplicant</a></h1>
<p>The <code>wpa_supplicant</code> package is installed by default on the base system. It
includes utilities to configure wireless interfaces and handle wireless
security protocols. To use wpa_supplicant, you will need to enable <a href="config/network/wpa_supplicant.html#the-wpa_supplicant-service">the
wpa_supplicant service</a>.</p>
<p><a href="https://man.voidlinux.org/wpa_supplicant.8">wpa_supplicant(8)</a> is a daemon
that manages wireless interfaces based on
<a href="https://man.voidlinux.org/wpa_supplicant.conf.5">wpa_supplicant.conf(5)</a>
configuration files. An extensive overview of configuration options,
including examples, can be found in
<code>/usr/share/examples/wpa_supplicant/wpa_supplicant.conf</code>.</p>
<p><a href="https://man.voidlinux.org/wpa_passphrase.8">wpa_passphrase(8)</a> helps create
pre-shared keys for use in configuration files.
<a href="https://man.voidlinux.org/wpa_cli.8">wpa_cli(8)</a> provides a CLI for
managing the <code>wpa_supplicant</code> daemon.</p>
<h2><a class="header" href="#wpa-psk" id="wpa-psk">WPA-PSK</a></h2>
<p>To use WPA-PSK, generate a pre-shared key with
<a href="https://man.voidlinux.org/wpa_passphrase.8">wpa_passphrase(8)</a> and append
the output to the relevant <code>wpa_supplicant.conf</code> file:</p>
<pre><code class="language-#wpa_passphrase&lt;MYSSID&gt;&lt;passphrase&gt;&gt;&gt;">/etc/wpa_supplicant/wpa_supplicant-&lt;device_name&gt;.conf ```

## WPA-EAP

WPA-EAP is often used for institutional logins, notably eduroam. This does
not use PSK, but a password hash can be generated like this:

``` $ echo -n &lt;passphrase&gt; | iconv -t utf16le | openssl md4 ```

## WEP

For WEP configuration, add the following lines to your device's
`wpa-supplicant.conf`:

</code></pre>
<p>network={
ssid=&quot;MYSSID&quot;
key_mgmt=NONE
wep_key0=&quot;YOUR AP WEP KEY&quot;
wep_tx_keyidx=0
auth_alg=SHARED
}</p>
<pre><code>
### The wpa_supplicant service

The `wpa_supplicant` service checks the following options in
`/etc/sv/wpa_supplicant/conf`:

- `OPTS`: Options to be passed to the service. Overrides any other options.
- `CONF_FILE`: Path to file to be used for configuration. Defaults to
   `/etc/wpa_supplicant/wpa_supplicant.conf`.
- `WPA_INTERFACE`: Interface to be matched. May contain a wildcard; defaults to
   all interfaces.
- `DRIVER`: Driver to use. See `wpa_supplicant -h` for available drivers.

If no `conf` file is found, the service searches for the following files in
`/etc/wpa_supplicant`:

- `wpa_supplicant-&lt;interface&gt;.conf`: If found, these files are bound to the
   named interface.
- `wpa_supplicant.conf`: If found, this file is loaded and binds to all other
   interfaces found.

Once you are satisfied with your configuration,
[enable](../services/index.md#enabling-services) the `wpa_supplicant`
service.

### Using wpa_cli

When using `wpa_cli` to manage `wpa_supplicant` from the command line, be
sure to specify which network interface to use via the `-i` option, e.g.:

``` # wpa_cli -i wlp2s0 ```

Not doing so can result in various `wpa_cli` commands (for example, `scan`
and `scan_results`) not producing the expected output.
</code></pre>
<h1><a class="header" href="#iwd" id="iwd">IWD</a></h1>
<p><a href="https://iwd.wiki.kernel.org/">IWD</a> (iNet Wireless Daemon) is a wireless
daemon for Linux that aims to replace <a href="config/network/./wpa_supplicant.html">WPA supplicant</a>.</p>
<h2><a class="header" href="#installation-2" id="installation-2">Installation</a></h2>
<p>Install the <code>iwd</code> package and enable the <code>dbus</code> and <code>iwd</code> services.</p>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>The command-line client <a href="https://man.voidlinux.org/iwctl.1">iwctl(1)</a> can be
used to add, remove, and configure network connections. Commands can be
passed as arguments; when run without arguments, it provides an interactive
session. To list available commands, run <code>iwctl help</code>, or run <code>iwctl</code> and
enter <code>help</code> at the interactive prompt.</p>
<p>By default, only the root user and those in the <code>wheel</code> group have
permission to operate <code>iwctl</code>.</p>
<h2><a class="header" href="#configuration-1" id="configuration-1">Configuration</a></h2>
<p>Configuration options and examples are described below. Consult the relevant
manual pages and the <a href="https://iwd.wiki.kernel.org/networkconfigurationsettings">upstream
documentation</a> for
further information.</p>
<h3><a class="header" href="#daemon-configuration" id="daemon-configuration">Daemon configuration</a></h3>
<p>The main configuration file is located in <code>/etc/iwd/main.conf</code>. If it does
not exist, you may create it. It is documented in
<a href="https://man.voidlinux.org/iwd.config.5">iwd.config(5)</a>.</p>
<h3><a class="header" href="#network-configuration" id="network-configuration">Network configuration</a></h3>
<p>Network configuration, including examples, is documented in
<a href="https://man.voidlinux.org/iwd.network.5">iwd.network(5)</a>. IWD stores
information on known networks, and reads information on pre-provisioned
networks from network configuration files located in <code>/var/lib/iwd</code>; IWD
monitors the directory for changes. Network configuration filenames consist
of the encoding of the SSID followed by <code>.open</code>, <code>.psk</code>, or <code>.8021x</code> as
determined by the security type.</p>
<p>As an example, a basic configuration file for a WPA2/PSK secured network
would be called <code>&lt;ssid&gt;.psk</code>, and it would contain the plain text password:</p>
<p><code>[Security] Passphrase=&lt;password&gt;</code></p>
<h2><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h2>
<p>By default, IWD will create and destroy the wireless interfaces
(e.g. <code>wlan0</code>)  that it manages. This can interfere with <code>udevd</code>, which may
attempt to rename the interface using its rules for persistent network
interface names. The following messages may be printed to your screen as a
symptom of this interference:</p>
<pre><code>[   39.441723] udevd[1100]: Error changing net interface name wlan0 to wlp59s0: Device or resource busy
[   39.442472] udevd[1100]: could not rename interface '3' from 'wlan0' to 'wlp59s0': Device or resource busy
</code></pre>
<p>A simple fix is to prevent IWD from manipulating the network interfaces in
this way by adding <code>UseDefaultInterface=true</code> to the <code>[General]</code> section of
<code>/etc/iwd/main.conf</code>.</p>
<p>An alternative approach is to disable the use of persistent network
interface names by <code>udevd</code>. This may be accomplished either by adding
<code>net.ifnames=0</code> to your kernel <a href="config/network/../kernel.html#cmdline">cmdline</a> or by
creating a symbolic link to <code>/dev/null</code> at
<code>/etc/udev/rules.d/80-net-name-slot.rules</code> to mask the renaming rule. This
alternative approach will affect the naming of all network devices.</p>
<h1><a class="header" href="#networkmanager" id="networkmanager">NetworkManager</a></h1>
<p><a href="https://man.voidlinux.org/NetworkManager.8">NetworkManager(8)</a> is a daemon
that manages Ethernet, Wi-Fi, and mobile broadband network
connections. Install the <code>NetworkManager</code> package for the basic
NetworkManager utilities.</p>
<h2><a class="header" href="#starting-networkmanager" id="starting-networkmanager">Starting NetworkManager</a></h2>
<p>Before enabling the NetworkManager daemon, <a href="config/network/../services/index.html">disable</a>
any other network management services, such as <a href="config/network/./index.html#dhcpcd">dhcpcd</a>,
<a href="config/network/./wpa_supplicant.html">wpa_supplicant</a>, or <code>wicd</code>. These services all control
network interface configuration, and will interfere with NetworkManager.</p>
<p>Also ensure that the <code>dbus</code> service is <a href="config/network/../services/index.html">enabled</a> and
running. NetworkManager uses <code>dbus</code> to expose networking information and a
control interface to clients, and will fail to start without it.</p>
<p>Finally, enable the <code>NetworkManager</code> service.</p>
<h2><a class="header" href="#configuring-networkmanager" id="configuring-networkmanager">Configuring NetworkManager</a></h2>
<p>Users of NetworkManager must belong to the <code>network</code> group.</p>
<p>The <code>NetworkManager</code> package includes a command line tool,
<a href="https://man.voidlinux.org/nmcli.1">nmcli(1)</a>, and a text-based user
interface, <a href="https://man.voidlinux.org/nmtui.1">nmtui(1)</a>, to control network
settings.</p>
<p>There are many other front-ends to NetworkManager, including <code>nm-applet</code> for
system trays, <code>nm-plasma</code> for KDE Plasma, and a built-in network
configuration tool in GNOME.</p>
<h2><a class="header" href="#eduroam-with-networkmanager" id="eduroam-with-networkmanager">Eduroam with NetworkManager</a></h2>
<p>Eduroam is a roaming service providing international, secure Internet access
at universities and other academic institutions. More information can be
found <a href="https://www.eduroam.org/">here</a>.</p>
<h3><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h3>
<p>Install the <code>python3-dbus</code> package.</p>
<h3><a class="header" href="#installation-3" id="installation-3">Installation</a></h3>
<p>Download the correct eduroam_cat installer for your institution from
<a href="https://cat.eduroam.org/">here</a> and execute it. It will provide a user
interface guiding you through the process.</p>
<h1><a class="header" href="#connman" id="connman">ConnMan</a></h1>
<p><a href="https://man.voidlinux.org/connman.8">ConnMan(8)</a> is a daemon that manages
network connections, is designed to be slim and to use as few resources as
possible. The <code>connman</code> package contains the basic utilities to run ConnMan.</p>
<h2><a class="header" href="#starting-connman" id="starting-connman">Starting ConnMan</a></h2>
<p>To enable the ConnMan daemon, first <a href="config/network/../services/index.html">disable</a> any
other network managing services like <a href="config/network/./index.html#dhcpcd">dhcpcd</a>,
<a href="config/network/./wpa_supplicant.html">wpa_supplicant</a>, or <code>wicd</code>. These services all control
network interface configuration, and interfere with each other.</p>
<p>Finally, enable the <code>connmand</code> service.</p>
<h2><a class="header" href="#configuring-connman" id="configuring-connman">Configuring ConnMan</a></h2>
<h3><a class="header" href="#connman-cli" id="connman-cli">ConnMan CLI</a></h3>
<p>The <code>connman</code> package includes a command line tool,
<a href="https://man.voidlinux.org/connmanctl.1">connmanctl(1)</a> to control network
settings. If you do not provide any commands, <code>connmanctl</code> starts as an
interactive shell.</p>
<p>Establishing a connection to an access point using the <code>connmanctl</code>
interactive shell might look as follows:</p>
<pre><code class="language-#connmanctl&gt;enablewifi&gt;agenton&gt;scanwifi&gt;services&gt;connect">wifi_&lt;uniqueid&gt; &gt; exit ```

### ConnMan Front-End Tools

There are many other front-ends to ConnMan, including `connman-ui` for
system trays, `connman-gtk` for GTK, `cmst` for QT and `connman-ncurses` for
ncurses based UI.

## Preventing DNS overrides by ConnMan

Create `/etc/sv/connmand/conf` with the following content:

``` OPTS=&quot;--nodnsproxy&quot; ```
</code></pre>
<h1><a class="header" href="#network-filesystems" id="network-filesystems">Network Filesystems</a></h1>
<h2><a class="header" href="#nfs" id="nfs">NFS</a></h2>
<h3><a class="header" href="#mounting-an-nfs-share" id="mounting-an-nfs-share">Mounting an NFS Share</a></h3>
<p>To mount an NFS share, start by installing the <code>nfs-utils</code> and <code>sv-netmount</code>
packages.</p>
<p>Before mounting an NFS share,
<a href="config/./services/index.html#enabling-services">enable</a>  the <code>statd</code>, <code>rpcbind</code>, and
<code>netmount</code> services. If the server supports <code>nfs4</code>, the <code>statd</code> service
isn't necessary.</p>
<p>To mount an NFS share:</p>
<p><code># mount -t &lt;mount_type&gt; &lt;host&gt;:/path/to/sourcedir /path/to/destdir</code></p>
<p><code>&lt;mount_type&gt;</code> should be <code>nfs4</code> if the server supports it, or <code>nfs</code>
otherwise.  <code>&lt;host&gt;</code> can be either the hostname or IP address of the server.</p>
<p>Mounting options can be found in
<a href="https://man.voidlinux.org/mount.nfs.8">mount.nfs(8)</a>, while unmounting
options can be found in
<a href="https://man.voidlinux.org/umount.nfs.8">umount.nfs(8)</a>.</p>
<p>For example, to connect <code>/volume</code> on a server at <code>192.168.1.99</code> to an
existing <code>/mnt/volume</code> directory on your local system:</p>
<p><code># mount -t nfs 192.168.1.99:/volume /mnt/volume</code></p>
<p>To have the directory mounted when the system boots, add an entry to
<a href="https://man.voidlinux.org/fstab.5">fstab(5)</a>:</p>
<p><code>192.168.1.99:/volume /mnt/volume nfs rw,hard,intr 0 0</code></p>
<p>Refer to <a href="https://man.voidlinux.org/nfs.5">nfs(5)</a> for information about the
available mounting options.</p>
<h3><a class="header" href="#setting-up-a-server-nfsv4-kerberos-disabled" id="setting-up-a-server-nfsv4-kerberos-disabled">Setting up a server (NFSv4, Kerberos disabled)</a></h3>
<p>To run an NFS server, start by installing the <code>nfs-utils</code> package.</p>
<p>Edit <code>/etc/exports</code> to add a shared volume:</p>
<pre><code>/storage/foo    *.local(rw,no_subtree_check,no_root_squash)
</code></pre>
<p>This line exports the <code>/storage/foo</code> directory to any host in the local
domain, with read/write access. For information about the <code>no_subtree_check</code>
and <code>no_root_squash</code> options, and available options more generally, refer to
<a href="https://man.voidlinux.org/exports.5">exports(5)</a>.</p>
<p>Finally, <a href="config/./services/index.html#enabling-services">enable</a> the <code>rpcbind</code>,
<code>statd</code>, and <code>nfs-server</code> services.</p>
<p>This will start your NFS server. To check if the shares are working, use the
<a href="https://man.voidlinux.org/showmount.8">showmount(8)</a> utility to check the
NFS server status:</p>
<p><code># showmount -e localhost</code></p>
<p>You can use <a href="https://man.voidlinux.org/nfs.conf.5">nfs.conf(5)</a> to configure
your server.</p>
<h1><a class="header" href="#session-and-seat-management" id="session-and-seat-management">Session and Seat Management</a></h1>
<p>Session and seat management is not necessary for every setup, but it can be
used to safely create temporary runtime directories, provide access to
hardware devices and multi-seat capabilities, and control system shutdown.</p>
<h2><a class="header" href="#d-bus" id="d-bus">D-Bus</a></h2>
<p>D-Bus is an IPC (inter-process communication) mechanism used by userspace
software in Linux. D-Bus can provide a system bus and/or a session bus, the
latter being specific to a user session.</p>
<ul>
<li>To provide a system bus, you should <a href="config/./services/index.html">enable</a> the <code>dbus</code>
service. This might require a system reboot to work properly.</li>
<li>To provide a session bus, you can start a given program (usually a window
manager or interactive shell) with
<a href="https://man.voidlinux.org/dbus-run-session.1">dbus-run-session(1)</a>. Most
desktop environments, if launched through an adequate display manager, will
launch a D-Bus session themselves.</li>
</ul>
<p>Note that some software assumes the presence of a system bus, while other
software assumes the presence of a session bus.</p>
<h2><a class="header" href="#elogind-1" id="elogind-1">elogind</a></h2>
<p><a href="https://man.voidlinux.org/elogind.8">elogind(8)</a> manages user logins and
system power, as a standalone version of <code>systemd-logind</code>. elogind provides
necessary features for most desktop environments and Wayland compositors. It
can also be one of the mechanisms for rootless
<a href="config/./graphical-session/xorg.html">Xorg</a>.</p>
<p>Please read the &quot;<a href="config/./power-management.html">Power Management</a>&quot; section for
things to consider before installing elogind.</p>
<p>To make use of its features, install the <code>elogind</code> package and make sure the
<a href="config/session-management.html#d-bus">system D-Bus</a> is enabled. You might need to log out and in again.</p>
<p>If you're having any issues with elogind, <a href="config/./services/index.html">enable</a> its
service, as waiting for a D-Bus activation can lead to issues.</p>
<p>There is an alternative D-Bus configuration which takes advantage of elogind
for features such as seat detection. It requires installing the
<code>dbus-elogind</code>, <code>dbus-elogind-libs</code> and <code>dbus-elogind-x11</code> packages.</p>
<h1><a class="header" href="#graphical-session-1" id="graphical-session-1">Graphical Session</a></h1>
<p>In order to configure a graphical session, you need:</p>
<ul>
<li><a href="config/graphical-session/./graphics-drivers/index.html">Graphics drivers</a></li>
<li>A basis for your graphical session: <a href="config/graphical-session/./xorg.html">Xorg</a> or
<a href="config/graphical-session/./wayland.html">Wayland</a></li>
</ul>
<p>You may also need:</p>
<ul>
<li><a href="config/graphical-session/../session-management.html">Session management tools</a></li>
</ul>
<h1><a class="header" href="#graphics-drivers" id="graphics-drivers">Graphics Drivers</a></h1>
<p>This section covers basic graphics setup depending on the hardware
configuration of your system.</p>
<h2><a class="header" href="#section-contents-3" id="section-contents-3">Section Contents</a></h2>
<ul>
<li><a href="config/graphical-session/graphics-drivers/./amd.html">AMD or ATI</a>  - <a href="config/graphical-session/graphics-drivers/./intel.html">Intel</a>  - <a href="config/graphical-session/graphics-drivers/./nvidia.html">NVIDIA</a>  -
<a href="config/graphical-session/graphics-drivers/./optimus.html">NVIDIA Optimus</a></li>
</ul>
<h1><a class="header" href="#amd-or-ati" id="amd-or-ati">AMD or ATI</a></h1>
<p>AMD GPU support requires the <code>linux-firmware-amd</code> package. If you have
installed the <code>linux</code> or <code>linux-lts</code> packages, it will be installed as a
dependency. If you installed a version-specific kernel package (e.g.,
<code>linux5.4</code>), it may be necessary to manually install <code>linux-firmware-amd</code>.</p>
<h2><a class="header" href="#opengl" id="opengl">OpenGL</a></h2>
<p>Install the Mesa DRI package, <code>mesa-dri</code>. This is already included in the
<code>xorg</code> meta-package, but it is needed when installing Xorg via
<code>xorg-minimal</code> or for running a Wayland compositor.</p>
<h2><a class="header" href="#vulkan" id="vulkan">Vulkan</a></h2>
<p>Install <code>vulkan-loader</code>, the Khronos Vulkan Loader. Then install one or both
of the Mesa AMD Vulkan driver, <code>mesa-vulkan-radeon</code>; or the GPUOpen AMD
Vulkan driver, <code>amdvlk</code>.</p>
<h2><a class="header" href="#xorg" id="xorg">Xorg</a></h2>
<p>Installing the <code>xorg</code> meta-package will pull in both <code>xf86-video-amdgpu</code>
and, for older hardware, <code>xf86-video-ati</code>. If you install <code>xorg-minimal</code>,
choose one of these Xorg driver packages to match your hardware. The
<code>amdgpu</code> driver should support cards built on AMD's &quot;Graphics Core Next 1.2&quot;
architecture, introduced circa 2012.</p>
<h2><a class="header" href="#video-acceleration" id="video-acceleration">Video acceleration</a></h2>
<p>Install the <code>mesa-vaapi</code> and <code>mesa-vdpau</code> packages.</p>
<h1><a class="header" href="#intel-1" id="intel-1">Intel</a></h1>
<p>Intel GPU support requires the <code>linux-firmware-intel</code> package. If you have
installed the <code>linux</code> or <code>linux-lts</code> packages, it will be installed as a
dependency. If you installed a version-specific kernel package (e.g.,
<code>linux5.4</code>), it may be necessary to manually install <code>linux-firmware-intel</code>.</p>
<h2><a class="header" href="#opengl-1" id="opengl-1">OpenGL</a></h2>
<p>OpenGL requires the Mesa DRI package, <code>mesa-dri</code>. This is provided by the
<code>xorg</code> meta-package, but will need to be installed manually when using the
<code>xorg-minimal</code> package or running a Wayland compositor.</p>
<h2><a class="header" href="#vulkan-1" id="vulkan-1">Vulkan</a></h2>
<p>Install the Khronos Vulkan Loader and the Mesa Intel Vulkan driver packages,
respectively <code>vulkan-loader</code> and <code>mesa-vulkan-intel</code>.</p>
<h2><a class="header" href="#video-acceleration-1" id="video-acceleration-1">Video acceleration</a></h2>
<p>Install the <code>intel-video-accel</code> meta-package:</p>
<p>This will install all the Intel VA-API drivers. <code>intel-media-driver</code> will be
used by default, but this choice can be overridden at runtime via the
environment variable <code>LIBVA_DRIVER_NAME</code>:</p>
<table><thead><tr><th>Driver Package</th><th>Supported GPU Gen</th><th>Explicit selection</th></tr></thead><tbody>
<tr><td><code>libva-intel-driver</code></td><td>up to Coffee Lake</td><td><code>LIBVA_DRIVER_NAME=i965</code></td></tr>
<tr><td><code>intel-media-driver</code></td><td>from Broadwell</td><td><code>LIBVA_DRIVER_NAME=iHD</code></td></tr>
</tbody></table>
<h2><a class="header" href="#troubleshooting-1" id="troubleshooting-1">Troubleshooting</a></h2>
<p>The kernels packaged by Void are configured with
<code>CONFIG_INTEL_IOMMU_DEFAULT_ON=y</code>, which can lead to issues with their
graphics drivers, as reported by the <a href="https://www.kernel.org/doc/html/latest/x86/intel-iommu.html#graphics-problems">kernel
documentation</a>.
To fix this, it is necessary to disable IOMMU for the integrated GPU. This
can be done by adding <code>intel_iommu=igfx_off</code> to your <a href="config/graphical-session/graphics-drivers/../../kernel.html#cmdline">kernel
cmdline</a>. This problem is expected to happen on the
Broadwell generation of internal GPUs. If you have another internal GPU and
your issues are fixed by this kernel option, you should file a bug reporting
the problem to kernel developers.</p>
<h1><a class="header" href="#nvidia" id="nvidia">NVIDIA</a></h1>
<h2><a class="header" href="#nouveau-open-source-driver" id="nouveau-open-source-driver">nouveau (Open Source Driver)</a></h2>
<p>This driver is developed mostly by the community, with little input from
Nvidia, and is not as performant as the proprietary driver. It is required
in order to run most Wayland compositors.</p>
<p>Install the <code>mesa-dri</code> driver or the <code>xf86-video-nouveau</code> driver.</p>
<p>Xorg can make use of either of the above mentioned drivers. The latter is
older, more stable and generally the recommended option. However, for newer
devices you might get better performance by using the <code>mesa-dri</code> provided
driver.</p>
<p>Note: <code>xf86-video-nouveau</code> is already included in the <code>xorg</code> meta-package,
but is needed when installing via <code>xorg-minimal</code>.</p>
<p>For using Wayland, users should install the <code>mesa-dri</code> provided driver.</p>
<h2><a class="header" href="#nvidia-proprietary-driver" id="nvidia-proprietary-driver">nvidia (Proprietary Driver)</a></h2>
<p>The proprietary drivers are available in the <a href="config/graphical-session/graphics-drivers/../../../xbps/repositories/index.html#nonfree">nonfree
repository</a>.</p>
<p>Check if your graphics card belongs to the <a href="https://www.nvidia.com/en-us/drivers/unix/legacy-gpu/">legacy
branch</a>. If it does
not, install the <code>nvidia</code> package. Otherwise you should install the
appropriate legacy driver, either <code>nvidia390</code> or <code>nvidia340</code>.</p>
<table><thead><tr><th>Brand</th><th>Type</th><th>Model</th><th>Driver Package</th></tr></thead><tbody>
<tr><td>NVIDIA</td><td>Proprietary</td><td>600+</td><td><code>nvidia</code></td></tr>
<tr><td>NVIDIA</td><td>Proprietary</td><td>300/400/500 Series</td><td><code>nvidia390</code></td></tr>
<tr><td>NVIDIA</td><td>Proprietary</td><td>GeForce8/9 + 100/200/300 Series</td><td><code>nvidia340</code></td></tr>
</tbody></table>
<p>The proprietary driver integrates in the kernel through
<a href="config/graphical-session/graphics-drivers/../../kernel.html#dynamic-kernel-module-support-dkms">DKMS</a>.</p>
<p>This driver offers better performance and power handling, and is recommended
where performance is needed.</p>
<h2><a class="header" href="#32-bit-program-support-glibc-only" id="32-bit-program-support-glibc-only">32-bit program support (glibc only)</a></h2>
<p>In order to run 32-bit programs with driver support, you need to install
additional packages.</p>
<p>If using the <code>nouveau</code> driver, install the <code>mesa-dri-32bit</code> package.</p>
<p>If using the <code>nvidia</code> driver, install the <code>nvidia&lt;x&gt;-libs-32bit</code>
package. <code>&lt;x&gt;</code> represents the legacy driver version (340 or 390) or can be
left empty for the main driver.</p>
<h2><a class="header" href="#reverting-from-nvidia-to-nouveau" id="reverting-from-nvidia-to-nouveau">Reverting from nvidia to nouveau</a></h2>
<h3><a class="header" href="#uninstalling-nvidia" id="uninstalling-nvidia">Uninstalling nvidia</a></h3>
<p>In order to revert to the <code>nouveau</code> driver, install the <a href="config/graphical-session/graphics-drivers/nvidia.html#nouveau-open-source-driver"><code>nouveau</code>
driver</a> (if it was not installed already), then
remove the <code>nvidia</code>, <code>nvidia390</code> or <code>nvidia340</code> package, as appropriate.</p>
<p>If you were using the <code>nvidia340</code> driver, you will need to install the
<code>libglvnd</code> package after removing the <code>nvidia340</code> package.</p>
<h3><a class="header" href="#keeping-both-drivers" id="keeping-both-drivers">Keeping both drivers</a></h3>
<p>It is possible to use the <code>nouveau</code> driver while still having the <code>nvidia</code>
driver installed. To do so, remove the blacklisting of <code>nouveau</code> in
<code>/etc/modprobe.d/nouveau_blacklist.conf</code>, <code>/usr/lib/modprobe.d/nvidia.conf</code>,
or <code>/usr/lib/modprobe.d/nvidia-dkms.conf</code> by commenting it out:</p>
<p><code>#blacklist nouveau</code></p>
<p>For Xorg, specify that it should load the <code>nouveau</code> driver rather than the
<code>nvidia</code> driver by creating the file <code>/etc/X11/xorg.conf.d/20-nouveau.conf</code>
with the following content:</p>
<pre><code>Section &quot;Device&quot;
    Identifier &quot;Nvidia card&quot;
    Driver &quot;nouveau&quot;
EndSection
</code></pre>
<p>You may need to reboot your system for these changes to take effect.</p>
<h1><a class="header" href="#nvidia-optimus" id="nvidia-optimus">NVIDIA Optimus</a></h1>
<p>NVIDIA Optimus refers to a dual graphics configuration found on laptops
consisting of an Intel integrated GPU and a discrete NVIDIA GPU.</p>
<p>There are different methods to take advantage of the NVIDIA GPU, which
depend on the driver version supported by your hardware.</p>
<p>In order to determine the correct driver to install, it is not enough to
look at the &quot;Supported Products&quot; list on NVIDIA's website, because they are
not guaranteed to work in an Optimus configuration. So the only way is to
try installing the latest <code>nvidia</code>, rebooting, and looking at the kernel
log. If your device is not supported, you will see a message like this:</p>
<pre><code class="language-NVRM:TheNVIDIAGPUxxxx:xx:xx.x(PCIID:xxxx:xxxx)NVRM:installed">in this system is not supported by the xxx.xx NVRM: NVIDIA Linux driver
release.  Please see 'Appendix NVRM: A - Supported NVIDIA GPU Products' in
this release's NVRM: README, available on the Linux driver download page
NVRM: at www.nvidia.com.  ```

which means you have to uninstall `nvidia` and install the legacy
`nvidia390`.

A summary of the methods supported by Void, which are mutually exclusive:

[PRIME Render Offload](#prime-render-offload)

- only available on `nvidia`
- allows to switch to the NVIDIA GPU on a per-application basis
- more flexible but power saving capabilities depend on the hardware (pre-Turing
   devices are not shut down completely)

Offloading Graphics Display with RandR 1.4

- available on `nvidia` and `nvidia390`
- allows to choose which GPU to use at the start of the X session
- less flexible, but allows the user to completely shut down the NVIDIA GPU when
   not in use, thus saving power

[Bumblebee](#bumblebee)

- available on `nvidia` and `nvidia390` - allows to switch to the NVIDIA GPU
on a per-application basis - unofficial method, offers poor performance

[Nouveau PRIME](#nouveau-prime)

- uses the open source driver `nouveau` - allows to switch to the NVIDIA GPU
on a per-application basis - `nouveau` is a reverse-engineered driver and
offers poor performance

You can check the currently used GPU by searching for `renderer string` in
the output of the `glxinfo` command. It is necessary to install the
`glxinfo` package for this.

## PRIME Render Offload

In this method, GPU switching is done by setting environment variables when
executing the application to be rendered on the NVIDIA GPU. The wrapper
script `prime-run` is available from the `nvidia` package, and can be used
as shown below:

``` $ prime-run &lt;application&gt; ```

For more information, see NVIDIA's
[README](https://download.nvidia.com/XFree86/Linux-x86_64/440.44/README/primerenderoffload.html)

## Bumblebee

Enable the `bumblebeed` service and add the user to the `bumblebee`
group. This requires a re-login to take effect.

Run the application to be rendered on the NVIDIA GPU with `optirun`:

``` $ optirun &lt;application&gt; ```

## Nouveau PRIME

This method uses the open source `nouveau` driver. If the NVIDIA drivers are
installed, it is necessary to [configure the system to use
`nouveau`](./nvidia.md#reverting-from-nvidia-to-nouveau).

Set `DRI_PRIME=1` to run an application on the NVIDIA GPU:

``` $ DRI_PRIME=1 &lt;application&gt; ```
</code></pre>
<h1><a class="header" href="#xorg-1" id="xorg-1">Xorg</a></h1>
<p>This section details the manual installation and configuration of the Xorg
display server and common related services and utilities. If you would just
like to install a full desktop environment, it is recommended to try one of
the <a href="config/graphical-session/../../installation/live-images/index.html#flavor-images">flavor images</a></p>
<h2><a class="header" href="#installation-4" id="installation-4">Installation</a></h2>
<p>Void provides a comprehensive <code>xorg</code> package which installs the server and
all of the free video drivers, input drivers, fonts, and base
applications. This package is a safe option, and should be adequate for most
systems which don't require proprietary video drivers.</p>
<p>If you would like to select only the packages you need, the <code>xorg-minimal</code>
package contains the base xorg server <em>only</em>. If you install only
<code>xorg-minimal</code>, you will likely need to install a font package (like
<code>xorg-fonts</code>), a terminal emulator (like <code>xterm</code>), and a window manager to
have a usable graphics system.</p>
<h2><a class="header" href="#video-drivers" id="video-drivers">Video Drivers</a></h2>
<p>Void provides both open-source and proprietary (non-free) video drivers.</p>
<h3><a class="header" href="#open-source-drivers" id="open-source-drivers">Open Source Drivers</a></h3>
<p>Xorg can use two categories of open source drivers: DDX or modesetting.</p>
<h4><a class="header" href="#ddx" id="ddx">DDX</a></h4>
<p>The DDX drivers are installed with the <code>xorg</code> package by default, or may be
installed individually if the <code>xorg-minimal</code> package was installed. They are
provided by the <code>xf86-video-*</code> packages.</p>
<p>For advanced configuration, see the man page corresponding to the vendor
name, like <a href="https://man.voidlinux.org/intel.4">intel(4)</a>.</p>
<h4><a class="header" href="#modesetting" id="modesetting">Modesetting</a></h4>
<p>Modesetting requires the <code>mesa-dri</code> package, and no additional
vendor-specific driver package.</p>
<p>Xorg defaults to DDX drivers if they are present, so in this case
modesetting must be explicitly selected: see <a href="config/graphical-session/xorg.html#forcing-the-modesetting-driver">Forcing the modesetting
driver</a>.</p>
<p>For advanced configuration, see
<a href="https://man.voidlinux.org/modesetting.4">modesetting(4)</a>.</p>
<h3><a class="header" href="#proprietary-drivers" id="proprietary-drivers">Proprietary Drivers</a></h3>
<p>Void also provides <a href="config/graphical-session/./graphics-drivers/nvidia.html">proprietary NVIDIA
drivers</a>, which are available in the <a href="config/graphical-session/../../xbps/repositories/index.html#nonfree">nonfree
repository</a>.</p>
<h2><a class="header" href="#input-drivers" id="input-drivers">Input Drivers</a></h2>
<p>A number of input drivers are available for Xorg. If <code>xorg-minimal</code> was
installed and a device is not responding, or behaving unexpectedly, a
different driver may correct the issue. These drivers can grab everything
from power buttons to mice and keyboards. They are provided by the
<code>xf86-input-*</code> packages.</p>
<h2><a class="header" href="#xorg-configuration" id="xorg-configuration">Xorg Configuration</a></h2>
<p>Although Xorg normally auto-detects drivers and configuration is not needed,
a config for a specific keyboard driver may look something like a file
<code>/etc/X11/xorg.conf.d/30-keyboard.conf</code> with the contents:</p>
<pre><code>Section &quot;InputClass&quot;
  Identifier &quot;keyboard-all&quot;
  Driver &quot;evdev&quot;
  MatchIsKeyboard &quot;on&quot;
EndSection
</code></pre>
<h3><a class="header" href="#forcing-the-modesetting-driver" id="forcing-the-modesetting-driver">Forcing the modesetting driver</a></h3>
<p>Create the file <code>/etc/X11/xorg.conf.d/10-modesetting.conf</code>:</p>
<pre><code>Section &quot;Device&quot;
    Identifier &quot;GPU0&quot;
    Driver &quot;modesetting&quot;
EndSection
</code></pre>
<p>and restart Xorg. Verify that the configuration has been picked up with:</p>
<p><code>$ grep -m1 '(II) modeset([0-9]+):' /var/log/Xorg.0.log</code></p>
<p>If there is a match, modesetting is being used.</p>
<h2><a class="header" href="#starting-x-sessions" id="starting-x-sessions">Starting X Sessions</a></h2>
<h3><a class="header" href="#startx" id="startx">startx</a></h3>
<p>The <code>xinit</code> package provides the
<a href="https://man.voidlinux.org/startx.1">startx(1)</a>  script as a frontend to
<a href="https://man.voidlinux.org/xinit.1">xinit(1)</a>, which can be used to start X
sessions from the console. For example, to use i3, edit <code>~/.xinitrc</code> to
contain:</p>
<p><code>exec /bin/i3</code></p>
<p>Then call <code>startx</code> to start an i3 session.</p>
<p>If a D-Bus session bus is required, you can <a href="config/graphical-session/../session-management.html#d-bus">manually start
one</a>.</p>
<h3><a class="header" href="#display-managers" id="display-managers">Display Managers</a></h3>
<p>Display managers (DMs) provide a graphical login UI. A number of DMs are
available in the Void repositories, including <code>gdm</code> (the GNOME DM), <code>sddm</code>
(the KDE DM) and <code>lightdm</code>. When setting up a display manager, be sure to
<a href="config/graphical-session/../services/index.html#testing-services">test the service</a> before enabling
it.</p>
<h1><a class="header" href="#wayland" id="wayland">Wayland</a></h1>
<p>This section details the manual installation and configuration of Wayland
compositors and related services and utilities.</p>
<h2><a class="header" href="#installation-5" id="installation-5">Installation</a></h2>
<p>Unlike <a href="config/graphical-session/./xorg.html">Xorg</a>, Wayland implementations combine the display
server, the window manager and the compositor in a single application.</p>
<h3><a class="header" href="#desktop-environments" id="desktop-environments">Desktop Environments</a></h3>
<p>GNOME, KDE Plasma and Enlightenment have Wayland sessions. GNOME uses its
Wayland session by default. When using these desktop environments,
applications built with GTK+ will automatically choose the Wayland backend,
while Qt5 and EFL applications might require <a href="config/graphical-session/wayland.html#native-applications">setting some environment
variables</a> if used outside KDE or Enlightenment,
respectively.</p>
<h3><a class="header" href="#standalone-compositors" id="standalone-compositors">Standalone compositors</a></h3>
<p>Void Linux currently packages the following Wayland compositors:</p>
<ul>
<li>Weston: reference compositor for Wayland - Sway: an i3-compatible Wayland
compositor - Wayfire: 3D Wayland compositor - Hikari: a stacking compositor
with some tiling features - Cage: a Wayland kiosk</li>
</ul>
<h3><a class="header" href="#video-drivers-1" id="video-drivers-1">Video drivers</a></h3>
<p>Both GNOME and KDE Plasma have EGLStreams backends for Wayland, which means
they can use the proprietary NVIDIA drivers. Most other Wayland compositors
require drivers that implement the GBM interface. The main driver for this
purpose is provided by the <code>mesa-dri</code> package. The &quot;<a href="config/graphical-session/./graphics-drivers/index.html">Graphics
Drivers</a>&quot; section has more details regarding
setting up graphics in different systems.</p>
<h3><a class="header" href="#native-applications" id="native-applications">Native applications</a></h3>
<p><a href="https://wayland.freedesktop.org/qt5.html">Qt5</a>-based applications require
installing the <code>qt5-wayland</code> package and setting the environment variable
<code>QT_QPA_PLATFORM=wayland-egl</code> to enable their Wayland backend. Some KDE
specific applications also require installing the <code>kwayland</code> package.
<a href="https://wayland.freedesktop.org/efl.html">EFL</a>-based applications require
setting the environment variable <code>ELM_DISPLAY=wl</code>, and can have issues
without it, due to not supporting XWayland properly.
<a href="https://wiki.gnome.org/Initiatives/Wayland/GTK%2B">GTK+</a>-based applications
should use the Wayland backend automatically. Information about other
toolkits can be found in the <a href="https://wayland.freedesktop.org/toolkits.html">Wayland
documentation</a>.</p>
<p>Media applications, such as <a href="https://man.voidlinux.org/mpv.1">mpv(1)</a>,
<a href="https://man.voidlinux.org/vlc.1">vlc(1)</a> and <code>imv</code> work natively on
Wayland.</p>
<h4><a class="header" href="#web-browsers" id="web-browsers">Web browsers</a></h4>
<p>Mozilla Firefox ships with a Wayland backend which is disabled by
default. To enable the Wayland backend, either set the environment variable
<code>MOZ_ENABLE_WAYLAND=1</code> before running <code>firefox</code> or use the provided
<code>firefox-wayland</code> script.</p>
<p>Browsers based on GTK+ or Qt5, such as Midori and
<a href="https://man.voidlinux.org/qutebrowser.1">qutebrowser(1)</a>, should work on
Wayland natively.</p>
<h4><a class="header" href="#running-x-applications-inside-wayland" id="running-x-applications-inside-wayland">Running X applications inside Wayland</a></h4>
<p>If an application doesn't support Wayland, it can still be used in a Wayland
context. XWayland is an X server that bridges this gap for most Wayland
compositors, and is installed as a dependency for most of them. Its package
is <code>xorg-server-xwayland</code>. For Weston, the correct package is
<code>weston-xwayland</code>.</p>
<h2><a class="header" href="#configuration-2" id="configuration-2">Configuration</a></h2>
<p>The Wayland API uses the <code>XDG_RUNTIME_DIR</code> environment variable to determine
the directory for the Wayland socket.</p>
<p>Install <code>elogind</code> as your <a href="config/graphical-session/../session-management.html">session manager</a> to
automatically setup <code>XDG_RUNTIME_DIR</code>.</p>
<p>Alternatively, manually set the environment variable through the shell. Make
sure to create a dedicated user directory and set its permissions to
<code>700</code>. A good default location is <code>/run/user/$(id -u)</code>.</p>
<p>It is also possible that some applications use the <code>XDG_SESSION_TYPE</code>
environment variable in some way, which requires that you set it to
<code>wayland</code>.</p>
<h1><a class="header" href="#fonts" id="fonts">Fonts</a></h1>
<p>To customize font display in your graphical session, you can use
configurations provided in <code>/usr/share/fontconfig/conf.avail/</code>. To do so,
create a symlink to the relevant <code>.conf</code> file in <code>/etc/fonts/conf.d/</code>, then
use <a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> to
reconfigure the <code>fontconfig</code> package.</p>
<p>For example, to disable use of bitmap fonts:</p>
<pre><code class="language-#ln-s/usr/share/fontconfig/conf.avail/70-no-bitmaps.conf">/etc/fonts/conf.d/ # xbps-reconfigure -f fontconfig ```

Use [fc-conflist(1)](https://man.voidlinux.org/fc-conflist.1) to list which
configurations are in effect.
</code></pre>
<h1><a class="header" href="#icons" id="icons">Icons</a></h1>
<h2><a class="header" href="#gtk" id="gtk">GTK</a></h2>
<p>By default, GTK-based applications try to use the Adwaita icon theme for
application icons. Consequently, installation of the <code>gtk+3</code> package will
also install the <code>adwaita-icon-theme</code> package. If you wish to use a
different theme, install the relevant package, then specify the theme in
<code>/etc/gtk-3.0/settings.ini</code> or <code>~/.config/gtk-3.0/settings.ini</code>.
<code>adwaita-icon-theme</code> can be removed after
<a href="config/graphical-session/../../xbps/advanced-usage.html#ignoring-packages">ignoring</a> the package.</p>
<p>For information about how to specify a different GTK icon theme in
<code>settings.ini</code>, refer to <a href="https://developer.gnome.org/gtk3/stable/GtkSettings.html#GtkSettings.properties">the GtkSettings
documentation</a>,
in particular the
&quot;<a href="https://developer.gnome.org/gtk3/stable/GtkSettings.html#GtkSettings--gtk-icon-theme-name">gtk-icon-theme-name</a>&quot;
property.</p>
<h1><a class="header" href="#gnome" id="gnome">GNOME</a></h1>
<h2><a class="header" href="#pre-installation" id="pre-installation">Pre-installation</a></h2>
<p>Install the <code>dbus</code> package, ensure the <code>dbus</code> service is enabled, and reboot
for the changes to take effect.</p>
<h2><a class="header" href="#installation-6" id="installation-6">Installation</a></h2>
<p>Install the <code>gnome</code> package for a GNOME environment which includes GNOME
applications.</p>
<p>A minimal GNOME environment can be created by installing the <code>mesa-dri</code>,
<code>gnome-session</code>, <code>gdm</code> and <code>adwaita-icon-theme</code> packages. (Note, however,
that not all GNOME features may be present or functional.)</p>
<p>The <code>gdm</code> package provides the <code>gdm</code> service for the GNOME Display Manager;
<a href="config/graphical-session/../services/index.html#testing-services">test the service</a> before enabling
it.  GDM defaults to providing a Wayland session via the <code>mutter</code> window
manager, but an X session can be chosen instead.</p>
<p>If you wish to start an X-based GNOME session from the console, use
<a href="config/graphical-session/./xorg.html#startx">startx</a> to run <code>gnome-session</code>.</p>
<p>GNOME applications can be installed via the <code>gnome-apps</code> package.</p>
<p>If you require <a href="http://www.zeroconf.org/">ZeroConf</a> support, install the
<code>avahi</code> package and enable the <code>avahi-daemon</code> service.</p>
<h1><a class="header" href="#kde" id="kde">KDE</a></h1>
<h2><a class="header" href="#installation-7" id="installation-7">Installation</a></h2>
<p>Install the <code>kde5</code> package, and optionally, the <code>kde5-baseapps</code> package.</p>
<p>To use the &quot;Networks&quot; widget, enable the <code>dbus</code> and <code>NetworkManager</code>
services.</p>
<p>Installing the <code>kde5</code> package also installs the <code>sddm</code> package, which
provides the <code>sddm</code> service for the Simple Desktop Display Manager. This
service depends on the <code>dbus</code> service being enabled; <a href="config/graphical-session/../services/index.html#testing-services">test the
service</a> before enabling it. If you
are not intending to run SDDM via a remote X server, you will need to
install either the <code>xorg-minimal</code> package or the <code>xorg</code> package. By default,
SDDM will start an X-based Plasma session, but you can request a
Wayland-based Plasma session instead.</p>
<p>If you wish to start an X-based session from the console, use
<a href="config/graphical-session/./xorg.html#startx">startx</a> to run <code>startplasma-x11</code>. For a Wayland-based
session, run <code>startplasma-wayland</code> directly.</p>
<h2><a class="header" href="#dolphin" id="dolphin">Dolphin</a></h2>
<p>Dolphin is the default file manager of the KDE desktop environment. It can
be installed on its own by installing the <code>dolphin</code> package, or it can be
installed as part of the <code>kde5-baseapps</code> meta-package.</p>
<h3><a class="header" href="#thumbnail-previews" id="thumbnail-previews">Thumbnail Previews</a></h3>
<p>To enable thumbnail file previews, install the <code>kdegraphics-thumbnailers</code>
package. If you want video thumbnails, the <code>ffmpegthumbs</code> package is also
necessary. Enable previews in &quot;Control&quot; -&gt; &quot;Configure Dolphin&quot; -&gt; &quot;General&quot;
-&gt; &quot;Previews&quot; by checking the corresponding boxes. File previews will be
shown for the selected file types after clicking &quot;Preview&quot; in Dolphin's
toolbar.</p>
<h1><a class="header" href="#multimedia" id="multimedia">Multimedia</a></h1>
<h2><a class="header" href="#audio-setup" id="audio-setup">Audio setup</a></h2>
<p>To setup audio on your Void Linux system you have to decide if you want to
use <a href="config/media/./pulseaudio.html">PulseAudio</a> or just <a href="config/media/./alsa.html">ALSA</a>.</p>
<p>Some applications require PulseAudio, especially closed source programs.</p>
<h1><a class="header" href="#alsa" id="alsa">ALSA</a></h1>
<p>To use ALSA, install the <code>alsa-utils</code> package and make sure your user is a
member of the <code>audio</code> group.</p>
<p>The <code>alsa-utils</code> package provides the <code>alsa</code> service. When enabled, this
service saves and restores the state of ALSA (e.g. volume) at shutdown and
boot, respectively.</p>
<p>To allow use of software requiring PulseAudio, install the <code>apulse</code>
package.  <code>apulse</code> provides part of the PulseAudio interface expected by
applications, translating calls to that interface into calls to ALSA. For
details about using <code>apulse</code>, consult <a href="https://github.com/i-rinat/apulse/blob/master/README.md">the project
README</a>.</p>
<h2><a class="header" href="#configuration-3" id="configuration-3">Configuration</a></h2>
<p>The default sound card can be specified via ALSA configuration files or via
kernel module options.</p>
<p>To obtain information about the order of loaded sound card modules:</p>
<pre><code>$ cat /proc/asound/modules
 0 snd_hda_intel
 1 snd_hda_intel
 2 snd_usb_audio
</code></pre>
<p>To set a different card as the default, edit <code>/etc/asound.conf</code> or the
per-user configuration file <code>~/.asoundrc</code>:</p>
<p><code>defaults.ctl.card 2; defaults.pcm.card 2;</code></p>
<p>or specify sound card module order in <code>/etc/modprobe.d/alsa.conf</code>:</p>
<p><code>options snd_usb_audio index=0</code></p>
<h2><a class="header" href="#dmix" id="dmix">Dmix</a></h2>
<p>The <code>dmix</code> ALSA plugin allows playing sound from multiple sources. <code>dmix</code> is
enabled by default for soundcards which do not support hardware mixing. To
enable it for digital output, edit <code>/etc/asound.conf</code>:</p>
<pre><code>pcm.dsp {
    type plug
    slave.pcm &quot;dmix&quot;
}
</code></pre>
<h1><a class="header" href="#pulseaudio" id="pulseaudio">PulseAudio</a></h1>
<p>Depending on which applications you use, you might need to provide
PulseAudio with a D-BUS session bus (e.g. via <code>dbus-run-session</code>) or a D-BUS
system bus (via the <code>dbus</code> service).</p>
<p>For applications which use ALSA directly and don't support PulseAudio, the
<code>alsa-plugins-pulseaudio</code> package can make them use PulseAudio through ALSA.</p>
<p>The PulseAudio package comes with a service file, which is not necessary in
most setups - the PulseAudio maintainers
<a href="https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/SystemWide/">discourage</a>
using a system-wide setup. Instead, PulseAudio will automatically start when
needed.</p>
<p>There are several methods of allowing PulseAudio to access to audio
devices. The simplest one is to add your user to the <code>audio</code>
group. Alternatively, you can use a session manager, like <code>elogind</code>.</p>
<h1><a class="header" href="#sndio" id="sndio">sndio</a></h1>
<p>Install the <code>sndio</code> package and enable the
<a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> service.</p>
<h2><a class="header" href="#configuration-4" id="configuration-4">Configuration</a></h2>
<p>The service can be configured by adding
<a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> flags to the <code>OPTS</code> variable
in the service configuration file (<code>/etc/sv/sndiod/conf</code>).</p>
<h3><a class="header" href="#default-device" id="default-device">Default device</a></h3>
<p><a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> uses the first ALSA device
by default. To use another ALSA device for sndio's default device <code>snd/0</code>
add the flags to use specific devices to the service configuration file.</p>
<p><code># echo 'OPTS=&quot;-f rsnd/Speaker&quot;' &gt;/etc/sv/sndiod/conf</code></p>
<p>Use the <code>-f</code> flag to chooses a device by its ALSA device index or its ALSA
device name.</p>
<h2><a class="header" href="#volume-control" id="volume-control">Volume control</a></h2>
<p>The master and per application volume controls are controlled with MIDI
messages by hardware or software.</p>
<p><a href="https://man.voidlinux.org/aucatctl.1">aucatctl(1)</a> is a tool specific to
sndio to send MIDI control messages to the
<a href="https://man.voidlinux.org/sndiod.8">sndiod(8)</a> daemon. It can be found in
the <code>aucatctl</code> package.</p>
<h2><a class="header" href="#application-specific-configurations" id="application-specific-configurations">Application specific configurations</a></h2>
<h3><a class="header" href="#firefox" id="firefox">Firefox</a></h3>
<p>Firefox is built with sndio support and should work out of the box since
version 71 if libsndio is installed and the <code>snd/0</code> device is available.</p>
<p>The following <code>about:config</code> changes are required for versions prior to 71
and should be removed when using version 71 or later:</p>
<pre><code class="language-media.cubeb.backend;sndiomedia.cubeb.sandbox;false">security.sandbox.content.read_path_whitelist;/home/&lt;username&gt;/.sndio/cookie
security.sandbox.content.write_path_whitelist;/home/&lt;username&gt;/.sndio/cookie
</code></pre>
<h3><a class="header" href="#mpv" id="mpv">mpv</a></h3>
<p>MPV comes with sndio support, but to prevent it from using ALSA over sndio
if the ALSA device is available, set the <code>--ao=sndio</code> command line
option. You can also add the option to mpv's configuration file:
<code>~/.config/mpv/mpv.conf</code> should contain a line specifying <code>ao=sndio</code>.</p>
<h3><a class="header" href="#openal" id="openal">OpenAL</a></h3>
<p>libopenal comes with sndio support, but prioritizes ALSA over sndio by
default.  You can configure this behavior per user in <code>~/.alsoftrc</code> or
system wide in <code>/etc/openal/alsoft.conf</code> by adding the following lines:</p>
<p><code>[general] drivers = sndio</code></p>
<h3><a class="header" href="#alsa-1" id="alsa-1">ALSA</a></h3>
<p>Applications that only have an ALSA backend can still use sndio with the
<code>alsa-sndio</code> package. It contains an ALSA plugin that provides a pcm that
connects to a <code>sndiod</code> server, and currently only supports playback. In
order to enable the pcm, add the lines below to your <a href="config/media/./alsa.html#configuration">ALSA configuration
file</a>:</p>
<pre><code>pcm.!default {
	type sndio
}
</code></pre>
<h1><a class="header" href="#bluetooth" id="bluetooth">Bluetooth</a></h1>
<p>Ensure the Bluetooth controller is not blocked. Use <code>rfkill</code> to check
whether there are any blocks and to remove soft blocks. If there is a hard
block, there is likely either a physical hardware switch or an option in the
BIOS to enable the Bluetooth controller.</p>
<pre><code>$ rfkill
ID TYPE     DEVICE      SOFT      HARD
0 wlan      phy0   unblocked unblocked
1 bluetooth hci0     blocked unblocked

# rfkill unblock bluetooth ```

## Installation

Install the `bluez` package and enable the `bluetoothd` and `dbus`
services.  Then, add your user to the `bluetooth` group and restart the
`dbus` service, or simply reboot the system. Note that restarting the `dbus`
service may kill processes making use of it.

To use an audio device such as a wireless speaker or headset, ALSA users
need to install the `bluez-alsa`
package. [PulseAudio](./media/pulseaudio.md) users do not need any
additional software.

## Usage

Manage Bluetooth connections and controllers using `bluetoothctl`, which
provides a command line interface and also accepts commands on standard
input.

Consult the [Arch
Wiki](https://wiki.archlinux.org/index.php/Bluetooth#Pairing)  for an
example of how to pair a device.

## Configuration

The main configuration file is `/etc/bluetooth/main.conf`.
</code></pre>
<h1><a class="header" href="#tex-live" id="tex-live">TeX Live</a></h1>
<p>In Void, the <code>texlive-bin</code> package provides a basic TeX installation,
including the <code>tlmgr</code> program. Use <code>tlmgr</code> to install TeX packages and
package collections from CTAN mirrors. Install the <code>gnupg</code> package to allow
<code>tlmgr</code> to verify TeX packages.</p>
<p>The <code>texlive-bin</code> package contains the latest TeX Live version; however,
earlier versions, such as <code>texlive2018-bin</code>, are also available.</p>
<h2><a class="header" href="#configuring-tex-live" id="configuring-tex-live">Configuring TeX Live</a></h2>
<p>After installing TeX Live, update the value of <code>PATH</code>:</p>
<p><code>$ source /etc/profile</code></p>
<p>Check that <code>/opt/texlive/&lt;year&gt;/bin/x86_64-linux</code> (or
<code>/opt/texlive/&lt;year&gt;/bin/i386-linux</code>) is in your <code>PATH</code>:</p>
<p><code>$ echo $PATH</code></p>
<p>If required, change the global default paper size:</p>
<p><code># tlmgr paper &lt;letter|a4&gt;</code></p>
<h2><a class="header" href="#installingupdating-tex-packages" id="installingupdating-tex-packages">Installing/Updating TeX packages</a></h2>
<p>To install all available packages:</p>
<p><code># tlmgr install scheme-full</code></p>
<p>To install specific packages, you can install the collection(s) including
them.  To list the available collections:</p>
<p><code>$ tlmgr info collections</code></p>
<p>To see the list of files owned by a collection:</p>
<p><code>$ tlmgr info --list collection-&lt;name&gt;</code></p>
<p>To install the collection:</p>
<p><code># tlmgr install collection-&lt;name&gt;</code></p>
<p>To install a standalone package, first check if the package exists:</p>
<p><code>$ tlmgr search --global &lt;package&gt;</code></p>
<p>and then install it:</p>
<p><code># tlmgr install &lt;package&gt;</code></p>
<p>To find the package providing a particular file (for example, a font):</p>
<p><code>$ tlmgr search --file &lt;filename&gt; --global</code></p>
<p>To remove a package or a collection:</p>
<p><code># tlmgr remove &lt;package&gt;</code></p>
<p>To update installed packages:</p>
<p><code># tlmgr update --all</code></p>
<p>For a full description, check:</p>
<p><a href="https://www.tug.org/texlive/doc/tlmgr.html">https://www.tug.org/texlive/doc/tlmgr.html</a></p>
<h1><a class="header" href="#external-applications" id="external-applications">External Applications</a></h1>
<h2><a class="header" href="#programming-languages" id="programming-languages">Programming Languages</a></h2>
<p>The Void repositories have a number of Python and Lua packages. If possible,
install packages from the Void repositories or consider packaging the
library or application you need. Packaging your application allows for
easier system maintenance and can benefit other Void Linux users, so
consider making a pull request for it. The contribution instructions can be
found
<a href="https://github.com/void-linux/void-packages/blob/master/CONTRIBUTING.md">here</a>.</p>
<p>To keep packages smaller, Void has separate <code>devel</code> packages for header
files and development tools. If you install a library or application via a
language's package manager (e.g. <code>pip</code>, <code>gem</code>), or compile one from source,
you may need to install the programming language's <code>-devel</code> package. This is
specially relevant for <code>musl</code> libc users, due to pre-built binaries usually
targeting <code>glibc</code> instead.</p>
<table><thead><tr><th>Language</th><th>Package Manager</th><th>Void Package</th></tr></thead><tbody>
<tr><td>Python3</td><td>pip, anaconda, virtualenv, etc</td><td><code>python3-devel</code></td></tr>
<tr><td>Python2</td><td>pip, anaconda, virtualenv, etc</td><td><code>python2-devel</code></td></tr>
<tr><td>Ruby</td><td>gem</td><td><code>ruby-devel</code></td></tr>
<tr><td>lua</td><td>luarocks</td><td><code>lua-devel</code></td></tr>
</tbody></table>
<h2><a class="header" href="#restricted-packages" id="restricted-packages">Restricted Packages</a></h2>
<p>Some packages have legal restrictions on their distribution (e.g. Discord),
may be too large, or have another condition that makes it difficult for Void
to distribute. These packages have build templates, but the packages
themselves are not built or distributed. As such, they must be built
locally. For more information see the page on <a href="config/../xbps/repositories/restricted.html">restricted
packages</a>.</p>
<h2><a class="header" href="#non-x86_64-arch" id="non-x86_64-arch">Non-x86_64 Arch</a></h2>
<p>The Void build system runs on x86_64 servers, both for compiling and cross
compiling packages. However, some packages (e.g. <code>libreoffice</code>) do not
support cross-compilation. These packages have to be built locally on a
computer running the same architecture and libc as the system on which the
package is to be used.  To learn how to build packages, refer to <a href="https://github.com/void-linux/void-packages/blob/master/README.md">the README
for the void-packages
repository</a>.</p>
<h2><a class="header" href="#flatpak" id="flatpak">Flatpak</a></h2>
<p>Flatpak is another method for installing external proprietary applications
on Linux. For information on using Flatpak with Void Linux, see the
<a href="https://flatpak.org/setup/Void%20Linux/">official Flatpak documentation</a>.</p>
<p>Note that Flatpak's sandboxing will not necessarily protect you from any
security and/or privacy-violating features of proprietary software.</p>
<h2><a class="header" href="#appimages" id="appimages">AppImages</a></h2>
<p>An <a href="https://appimage.org/">AppImage</a> is a file that bundles an application
with everything needed to run it. An AppImage can be used by making it
executable and running it; installation is not required. AppImages can be
run in a sandbox, such as <a href="https://firejail.wordpress.com/">firejail</a>.</p>
<p>Some of the applications for which an AppImage is available can be found on
<a href="https://appimage.github.io/">AppImageHub</a>.</p>
<p>AppImages do not yet work on musl installations.</p>
<h3><a class="header" href="#troubleshooting-2" id="troubleshooting-2">Troubleshooting</a></h3>
<p>Some apps may not function properly (e.g. not being able to access the host
system's files). Some of these issues can be fixed by installing one or more
of the <code>xdg-desktop-portal</code>, <code>xdg-desktop-portal-gtk</code>, <code>xdg-user-dirs</code>,
<code>xdg-user-dirs-gtk</code> or <code>xdg-utils</code> packages.</p>
<p>Some Flatpaks require <a href="config/./session-management.html#d-bus">D-Bus</a> and/or
<a href="config/./media/pulseaudio.html">Pulseaudio</a>.</p>
<h2><a class="header" href="#octave-packages" id="octave-packages">Octave Packages</a></h2>
<p>Some Octave packages require external dependencies to compile and run. For
example, to build the control package, you must install the
<code>openblas-devel</code>, <code>libgomp-devel</code>, <code>libgfortran-devel</code>, <code>gcc-fortran</code>, and
<code>gcc</code> packages.</p>
<h2><a class="header" href="#matlab" id="matlab">MATLAB</a></h2>
<p>To use MATLAB's help browser, live scripts, add-on installer, and simulink,
install the <code>libselinux</code> package.</p>
<h1><a class="header" href="#printing" id="printing">Printing</a></h1>
<p>CUPS (Common Unix Printing System) is the supported mechanism for connecting
to printers on Void Linux.</p>
<p>As prerequisites, install the <code>cups</code> package and enable the <code>cupsd</code>
service.  Wait until the service is marked available.</p>
<h2><a class="header" href="#installing-printing-drivers" id="installing-printing-drivers">Installing Printing Drivers</a></h2>
<p>If the printer is being accessed over the network and supports PostScript or
PCL, CUPS alone should be sufficient. However, additional driver packages
are necessary for local printer support. The <code>cups-filters</code> package provides
driver support for CUPS.</p>
<p>Depending on the hardware in question, additional drivers may be necessary.</p>
<p>Some CUPS drivers contain proprietary or binary-only extensions. These are
available only in the nonfree repository, and sometimes only for specific
architectures.</p>
<h3><a class="header" href="#gutenprint-drivers" id="gutenprint-drivers">Gutenprint drivers</a></h3>
<p>Gutenprint provides support for many printers. These drivers are contained
in the <code>gutenprint</code> package.</p>
<h3><a class="header" href="#hp-drivers" id="hp-drivers">HP drivers</a></h3>
<p>Printers from Hewlett-Packard require the <code>hplip</code> package.</p>
<p>Running the following command will guide you through the driver installation
process. The default configuration selections it suggests are typically
sufficient.</p>
<p><code># hp-setup -i</code></p>
<h3><a class="header" href="#brother-drivers" id="brother-drivers">Brother drivers</a></h3>
<p>For Brother printer support, install the foomatic drivers, which are
contained in the <code>foomatic-db</code> and <code>foomatic-db-nonfree</code> packages.</p>
<h2><a class="header" href="#configuring-a-new-printer" id="configuring-a-new-printer">Configuring a New Printer</a></h2>
<p>CUPS provides a web interface and command line tools that can be used to
configure printers. Additionally, various native GUI options are available
and may be better suited, depending on the use-case.</p>
<h3><a class="header" href="#web-interface" id="web-interface">Web interface</a></h3>
<p>To configure the printer using the CUPS web interface, navigate to
<a href="http://localhost:631">http://localhost:631</a> in a browser. Under the &quot;Administration&quot; tab, select
&quot;Printers &gt; Add Printer&quot;.</p>
<h3><a class="header" href="#command-line" id="command-line">Command line</a></h3>
<p>The <a href="https://man.voidlinux.org/lpadmin.8">lpadmin(8)</a> tool may be used to
configure a printer using the command line.</p>
<h3><a class="header" href="#graphical-interface" id="graphical-interface">Graphical interface</a></h3>
<p>The <code>system-config-printer</code> package offers simple and robust configuration
of new printers. Install and invoke it:</p>
<p><code># system-config-printer</code></p>
<p>Normally this tool requires root privileges. However, if you are using
PolicyKit, you can install the <code>cups-pk-helper</code> package to allow
unprivileged users to use <code>system-config-printer</code>.</p>
<p>While <code>system-config-printer</code> is shown here, your desktop environment may
have a native printer dialog, which may be found by consulting the
documentation for your DE.</p>
<h2><a class="header" href="#troubleshooting-3" id="troubleshooting-3">Troubleshooting</a></h2>
<h3><a class="header" href="#usb-printer-not-shown" id="usb-printer-not-shown">USB printer not shown</a></h3>
<p>The device URI can be found manually by running:</p>
<p><code># /usr/lib/cups/backend/usb</code></p>
<h1><a class="header" href="#containers-and-virtual-machines" id="containers-and-virtual-machines">Containers and Virtual Machines</a></h1>
<p>This section describes how to set up some of the container and virtual
machine software available on Void.</p>
<h2><a class="header" href="#section-contents-4" id="section-contents-4">Section Contents</a></h2>
<ul>
<li><a href="config/containers-and-vms/./libvirt.html">libvirt</a>  - <a href="config/containers-and-vms/./lxc.html">LXC</a></li>
</ul>
<h1><a class="header" href="#libvirt" id="libvirt">libvirt</a></h1>
<p><a href="https://libvirt.org/">libvirt</a> is an API and daemon for managing platform
virtualization, supporting virtualization technologies such as LXC, KVM,
QEMU, Bhyve, Xen, VMWare, and Hyper-V.</p>
<p>To use libvirt, install the <code>libvirt</code> package, ensure the <code>dbus</code> package is
installed, and <a href="config/containers-and-vms/../services/index.html#enabling-services">enable</a> the <code>dbus</code>,
<code>libvirtd</code>, <code>virtlockd</code> and <code>virtlogd</code> services. The <code>libvirtd</code> daemon can
be reconfigured at runtime via
<a href="https://man.voidlinux.org/virt-admin.1">virt-admin(1)</a>.</p>
<p>The <code>libvirt</code> package provides the
<a href="https://man.voidlinux.org/virsh.1">virsh(1)</a>  interface to
libvirtd. <code>virsh</code> is an interactive shell and batch-scriptable tool for
performing management tasks, including creating, configuring and running
virtual machines, and managing networks and storage. Note that <code>virsh</code>
usually needs to be run as root, as described in the <code>virsh</code> man page:</p>
<blockquote>
<p>Most virsh commands require root privileges to run due to the
communications &gt; channels used to talk to the hypervisor. Running as non
root will return an &gt; error.</p>
</blockquote>
<p>However, if you have the <code>polkit</code> and <code>dbus</code> packages installed and you
enable the <code>dbus</code> service, <code>libvirtd</code> will grant necessary privileges to any
user added to the <code>libvirt</code> group.</p>
<p>An alternative to <code>virsh</code> is provided by the <code>virt-manager</code> and
<code>virt-manager-tools</code> packages.</p>
<p>For general information on libvirt, refer to <a href="https://wiki.libvirt.org/page/Main_Page">the libvirt
wiki</a> and <a href="https://wiki.libvirt.org/page/FAQ">the wiki's
FAQ</a>. For an introduction to libvirt
usage, refer to <a href="https://wiki.libvirt.org/page/VM_lifecycle">the &quot;VM lifecycle&quot;
page</a>.</p>
<h1><a class="header" href="#lxc" id="lxc">LXC</a></h1>
<p>The <a href="https://linuxcontainers.org/">Linux Containers project</a> includes three
subprojects: <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>,
<a href="https://linuxcontainers.org/lxd/introduction/">LXD</a> and
<a href="https://linuxcontainers.org/lxcfs/introduction/">LXCFS</a>. The project also
included the CGManager project, which has been deprecated in favor of the
CGroup namespace in recent kernels.</p>
<h2><a class="header" href="#configuring-lxc" id="configuring-lxc">Configuring LXC</a></h2>
<p>Install the <code>lxc</code> package.</p>
<p>Creating and running privileged containers as <code>root</code> does not require any
configuration; simply use the various <code>lxc-*</code> commands, such as
<a href="https://man.voidlinux.org/lxc-create.1">lxc-create(1)</a>,
<a href="https://man.voidlinux.org/lxc-start.1">lxc-start(1)</a>,
<a href="https://man.voidlinux.org/lxc-attach.1">lxc-attach(1)</a>, etc.</p>
<h3><a class="header" href="#creating-unprivileged-containers" id="creating-unprivileged-containers">Creating unprivileged containers</a></h3>
<p>User IDs (UIDs) and group IDs (GIDs) normally range from 0 to 65535.
Unprivileged containers enhance security by mapping UID and GID ranges
inside each container to ranges not in use by the host system. The unused
host ranges must be <em>subordinated</em> to the user who will be running the
unprivileged containers.</p>
<p>Subordinate UIDs and GIDs are assigned in the
<a href="https://man.voidlinux.org/subuid.5">subuid(5)</a> and
<a href="https://man.voidlinux.org/subgid.5">subgid(5)</a> files, respectively.</p>
<p>To create unprivileged containers, first edit <code>/etc/subuid</code> and
<code>/etc/subgid</code> to delegate ranges. For example:</p>
<p><code>root:1000000:65536 user:2000000:65536</code></p>
<p>In each colon-delimited entry:</p>
<ul>
<li>the first field is the user to which a subordinate range will be assigned;</li>
<li>the second field is the smallest numeric ID defining a subordinate range;
and - the third field is the number of consecutive IDs in the range.</li>
</ul>
<p>The <a href="https://man.voidlinux.org/usermod.8">usermod(8)</a> program may also be
used to manipulate suborinated IDs.</p>
<p>Generally, the number of consecutive IDs should be an integer multiple of
65536; the starting value is not important, except to ensure that the
various ranges defined in the file do not overlap. In this example, <code>root</code>
controls UIDs (or, from <code>subgid</code>, GIDs) ranging from 1000000 to 1065535,
inclusive; <code>user</code> controls IDs ranging from 2000000 to 2065535.</p>
<p>Before creating a container, the user owning the container will need an
<a href="https://man.voidlinux.org/lxc.conf.5">lxc.conf(5)</a> file specifying the
subuid and subgid range to use. For root-owned containers, this file resides
at <code>/etc/lxc/default.conf</code>; for unprivileged users, the file resides at
<code>~/.config/lxc/default.conf</code>. Mappings are described in lines of the form</p>
<p><code>lxc.idmap = u 0 1000000 65536 lxc.idmap = g 0 1000000 65536</code></p>
<p>The isolated <code>u</code> character indicates a UID mapping, while the isolated <code>g</code>
indicates a GID mapping. The first numeric value should generally always be
0; this indicates the start of the UID or GID range <em>as seen from within the
container</em>. The second numeric value is the start of the corresponding range
<em>as seen from outside the container</em>, and may be an arbitrary value within
the range delegated in <code>/etc/subuid</code> or <code>/etc/subgid</code>. The final value is
the number of consecutive IDs to map.</p>
<p>Note that, although the external range start is arbitrary, care must be
taken to ensure that the end of the range implied by the start and number
does not extend beyond the range of IDs delegated to the user.</p>
<p>If configuring a non-root user, edit <code>/etc/lxc/lxc-usernet</code> as root to
specify a network device quota. For example, to allow the user named <code>user</code>
to create up to 10 <code>veth</code> devices connected to the <code>lxcbr0</code> bridge:</p>
<p><code>user veth lxcbr0 10</code></p>
<p>The user can now create and use unprivileged containers with the <code>lxc-*</code>
utilities. To create a simple Void container named <code>mycontainer</code>, use a
command similar to:</p>
<pre><code>lxc-create -n mycontainer -t download -- \
	--dist voidlinux --release current --arch x86_64
</code></pre>
<p>You may substitute another architecture for <code>x86_64</code>, and you may specify a
<code>musl</code> image by adding <code>--variant musl</code> to the end of the command. See the
<a href="http://images.linuxcontainers.org">LXC Image Server</a> for a list of
available containers.</p>
<p>By default, configurations and mountpoints for system containers are stored
in <code>/var/lib/lxc</code>, while configurations for user containers and mountpoints
are stored in <code>~/.local/share/lxc</code>. Both of these values can be modified by
setting <code>lxc.lxcpath</code> in the
<a href="https://man.voidlinux.org/lxc.system.conf.5">lxc.system.conf(5)</a> file. The
superuser may launch unprivileged containers in the system <code>lxc.lxcpath</code>
defined in <code>/etc/lxc/lxc.conf</code>; regular users may launch unprivileged
containers in the personal <code>lxc.lxcpath</code> defined in
<code>~/.config/lxc/lxc.conf</code>.</p>
<p>All containers will share the same subordinate UID and GID maps by
default. This is permissible, but it means that an attacker who gains
elevated access within one container, and can somehow break out of that
container, will have similar access to other containers. To isolate
containers from each other, alter the <code>lxc.idmap</code> ranges in <code>default.conf</code>
to point to a unique range <em>before</em> you create each container. Trying to fix
permissions on a container created with the wrong map is possible, but
inconvenient.</p>
<h2><a class="header" href="#lxd" id="lxd">LXD</a></h2>
<p>LXD provides an alternative interface to LXC's <code>lxc-*</code> utilities. However,
it does not require the configuration described in <a href="config/containers-and-vms/lxc.html#lxc">the previous
section</a>.</p>
<p>Install the <code>lxd</code> package, and
<a href="config/containers-and-vms/../services/index.html#enabling-services">enable</a>  the <code>lxd</code> service.</p>
<p>LXD users must belong to the <code>lxd</code> group.</p>
<p>Use the <code>lxc</code> command to manage instances, as described
<a href="https://linuxcontainers.org/lxd/getting-started-cli/#lxd-client">here</a>.</p>
<h1><a class="header" href="#menadżer-pakietów-xbps" id="menadżer-pakietów-xbps">Menadżer pakietów XBPS</a></h1>
<p>X Binary Package System (XBPS) to szybki menadżer pakietów zaprojektowany i
wykonany od podstaw. XBPS utrzymuje zespół Void Linuksa. Strona internetowa:
<a href="https://github.com/void-linux/xbps">https://github.com/void-linux/xbps</a>.</p>
<p>Most general package management is done with the following commands:</p>
<ul>
<li><a href="https://man.voidlinux.org/xbps-query.1">xbps-query(1)</a> searches for and
displays information about packages installed locally, or, if used with the
<code>-R</code> flag, packages contained in repositories.</li>
<li><a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> installs and
updates packages, and syncs repository indexes.</li>
<li><a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a> removes installed
packages, and can also remove orphaned packages and cached package files.</li>
<li><a href="https://man.voidlinux.org/xbps-reconfigure.1">xbps-reconfigure(1)</a> runs the
configuration steps for installed packages, and can be used to reconfigure
certain packages after changes in their configuration files. The latter
usually requires the <code>--force</code> flag.</li>
<li><a href="https://man.voidlinux.org/xbps-alternatives.1">xbps-alternatives(1)</a> lists or
sets the alternatives provided by installed packages. Alternatives is a
system which allows multiple packages to provide common functionality through
otherwise conflicting files, by creating symlinks from the common paths to
package-specific versions that are selected by the user.</li>
<li><a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a> can report and fix
issues in the package database, as well as modify it.</li>
<li><a href="https://man.voidlinux.org/xbps-rindex.1">xbps-rindex(1)</a> manages local binary
package repositories.</li>
</ul>
<p>Most questions can be answered by consulting the man pages for these tools,
together with the <a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> man page.</p>
<p>Instrukcję budowania pakietów z kodu źródłowego możesz znaleźć w <a href="https://github.com/void-linux/void-packages/blob/master/README.md">README
repozytorium void-packages
(ang.)</a>.</p>
<h2><a class="header" href="#aktualizowanie" id="aktualizowanie">Aktualizowanie</a></h2>
<p>Jak każdy system operacyjny, Void powiniem być regularnie aktualizowany. Do
aktualizacji służy polecenie
<a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a>:</p>
<p><code># xbps-install -Su</code></p>
<p>XBPS must use a separate transaction to update itself. If your update
includes the <code>xbps</code> package, you will need to run the above command a second
time to apply the rest of the updates.</p>
<h3><a class="header" href="#restarting-services" id="restarting-services">Restarting Services</a></h3>
<p>XBPS does not restart services when they are updated. This task is left to
the administrator, so they can orchestrate maintenance windows, ensure
reasonable backup capacity, and generally be present for service upgrades.</p>
<p>To find processes running different versions than are present on disk, use
the <code>xcheckrestart</code> tool provided by the <code>xtools</code> package:</p>
<pre><code class="language-$xcheckrestart11339/opt/google/chrome/chrome(deleted)">(google-chrome)  ```

`xcheckrestart` will print out the PID, path to the executable, status of
the path that was launched (almost always `deleted`) and the process name.

`xcheckrestart` can and should be run as an unprivileged user.

### Kernel Panic After Update

If you get a kernel panic after an update, it is likely your system ran out
of space in `/boot`. Refer to &quot;[Removing old
kernels](../config/kernel.md#removing-old-kernels)&quot; for further information.

## Finding Files and Packages

To search available repositories for packages, use
[xbps-query(1)](https://man.voidlinux.org/xbps-query.1):

``` $ xbps-query -Rs &lt;search_pattern&gt; ```

The `-R` flag specifies that repositories should be searched. Without it,
`-s` searches for locally-installed packages.

If you can't find a file or program you expected to find after installing a
package, you can use [xbps-query(1)](https://man.voidlinux.org/xbps-query.1)
to list the files provided by that package:

``` $ xbps-query -f &lt;package_name&gt; ```

The `xtools` package contains the
[xlocate(1)](https://man.voidlinux.org/xlocate.1) utility. `xlocate` works
like [locate(1)](https://man.voidlinux.org/locate.1), but for files in the
Void package repositories:

</code></pre>
<p>$ xlocate -S
Fetching objects: 11688, done.
From https://alpha.de.repo.voidlinux.org/xlocate/xlocate
+ e122c3634...a2659176f master     -&gt; master  (forced update)
$ xlocate xlocate
xtools-0.59_1   /usr/bin/xlocate
xtools-0.59_1   /usr/share/man/man1/xlocate.1 -&gt; /usr/share/man/man1/xtools.1</p>
<pre><code>
It is also possible to use
[xbps-query(1)](https://man.voidlinux.org/xbps-query.1) to find files,
though this is strongly discouraged:

``` $ xbps-query -Ro /usr/bin/xlocate xtools-0.46_1: /usr/bin/xlocate
(regular file)  ```

This requires `xbps-query` to download parts of every package to find the
file.  `xlocate`, however, queries a locally cached index of all files, so
no network access is required.

To get a list of all installed packages, without their version:

``` $ xbps-query -l | awk '{ print $2 }' | xargs -n1 xbps-uhelper getpkgname
</code></pre>
<h1><a class="header" href="#advanced-usage" id="advanced-usage">Advanced Usage</a></h1>
<h2><a class="header" href="#downgrading" id="downgrading">Downgrading</a></h2>
<p>XBPS allows you to downgrade a package to a specific package version.</p>
<h3><a class="header" href="#via-xdowngrade" id="via-xdowngrade">Via xdowngrade</a></h3>
<p>The easiest way to downgrade is to use <code>xdowngrade</code> from the <code>xtools</code>
package, specifying the package version to which you wish to downgrade:</p>
<p><code># xdowngrade /var/cache/xbps/pkg-1.0_1.xbps</code></p>
<h3><a class="header" href="#via-xbps" id="via-xbps">Via XBPS</a></h3>
<p>XBPS can be used to downgrade to a package version that is no longer
available in the repository index.</p>
<p>If the package version had been installed previously, it will be available
in <code>/var/cache/xbps/</code>. If not, it will need to be obtained from elsewhere;
for the purposes of this example, it will be assumed that the package
version has been added to <code>/var/cache/xbps/</code>.</p>
<p>First add the package version to your local repository:</p>
<p><code># xbps-rindex -a /var/cache/xbps/pkg-1.0_1.xbps</code></p>
<p>Then downgrade with <code>xbps-install</code>:</p>
<p><code># xbps-install -R /var/cache/xbps/ -f pkg-1.0_1</code></p>
<p>The <code>-f</code> flag is necessary to force downgrade/re-installation of an already
installed package.</p>
<h2><a class="header" href="#holding-packages" id="holding-packages">Holding packages</a></h2>
<p>To prevent a package from being updated during a system update, use
<a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a>:</p>
<p><code># xbps-pkgdb -m hold &lt;package&gt;</code></p>
<p>The hold can be removed with:</p>
<p><code># xbps-pkgdb -m unhold &lt;package&gt;</code></p>
<h2><a class="header" href="#repository-locking-packages" id="repository-locking-packages">Repository-locking packages</a></h2>
<p>If you've used <code>xbps-src</code> to build and install a package from a customized
template, or with custom build options, you may wish to prevent system
updates from replacing that package with a non-customized version. To ensure
that a package is only updated from the same repository used to install it,
you can <em>repolock</em> it via
<a href="https://man.voidlinux.org/xbps-pkgdb.1">xbps-pkgdb(1)</a>:</p>
<p><code># xbps-pkgdb -m repolock &lt;package&gt;</code></p>
<p>To remove the repolock:</p>
<p><code># xbps-pkgdb -m repounlock &lt;package&gt;</code></p>
<h2><a class="header" href="#ignoring-packages" id="ignoring-packages">Ignoring Packages</a></h2>
<p>Sometimes you may wish to remove a package whose functionality is being
provided by another package, but will be unable to do so due to dependency
issues. For example, you may wish to use
<a href="https://man.voidlinux.org/doas.1">doas(1)</a> instead of
<a href="https://man.voidlinux.org/sudo.8">sudo(8)</a>, but will be unable to remove
the <code>sudo</code> package due to it being a dependency of the <code>base-system</code>
package. To remove it, you will need to <em>ignore</em> the <code>sudo</code> package.</p>
<p>To ignore a package, add an appropriate <code>ignorepkg</code> entry in an
<a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> configuration file. For
example:</p>
<p><code>ignorepkg=sudo</code></p>
<p>You will then be able to remove the <code>sudo</code> package using
<a href="https://man.voidlinux.org/xbps-remove.1">xbps-remove(1)</a>.</p>
<h2><a class="header" href="#virtual-packages" id="virtual-packages">Virtual Packages</a></h2>
<p>Virtual packages can be created with
<a href="https://man.voidlinux.org/xbps.d.5">xbps.d(5)</a> <code>virtualpkg</code> entries. Any
request to the virtual package will be resolved to the real package. For
example, to create a <code>linux</code> virtual package which will resolve to the
<code>linux5.6</code> package, create an <code>xbps.d</code> configuration file with the contents:</p>
<p><code>virtualpkg=linux:linux5.6</code></p>
<h1><a class="header" href="#repositories" id="repositories">Repositories</a></h1>
<p>Repositories are the heart of the XBPS package system. Repositories can be
local or remote. A repository contains binary package files, which may have
signatures, and a data file named <code>$ARCH-repodata</code> (e.g. <code>x86_64-repodata</code>),
which may also be signed.</p>
<p>Note that, while local repositories do not require signatures, remote
repositories <em>must</em> be signed.</p>
<h2><a class="header" href="#the-main-repository" id="the-main-repository">The main repository</a></h2>
<p>The locations of the main repository in relation to a base <a href="xbps/repositories/./mirrors/index.html">mirror
URL</a> are:</p>
<ul>
<li>glibc: <code>/current</code> - musl: <code>/current/musl</code> - aarch64 and aarch64-musl:
<code>/current/aarch64</code></li>
</ul>
<h2><a class="header" href="#subrepositories" id="subrepositories">Subrepositories</a></h2>
<p>In addition to the main repository, which is enabled upon installation, Void
provides other official repositories maintained by the Void project, but not
enabled by default:</p>
<ul>
<li>nonfree: contains software packages with non-free licenses - multilib:
contains 32-bit libraries for 64-bit systems (glibc only)  -
multilib/nonfree: contains non-free multilib packages - debug: contains
debugging symbols for packages</li>
</ul>
<p>These repositories can be enabled via the installation of the relevant
package.  These packages only install a repository configuration file in
<code>/usr/share/xbps.d</code>.</p>
<h3><a class="header" href="#nonfree" id="nonfree">nonfree</a></h3>
<p>Void has a <code>nonfree</code> repository for packages that don't have free
licenses. It can enabled by installing the <code>void-repo-nonfree</code> package.</p>
<p>Packages can end up in the <code>nonfree</code> repository for a number of reasons:</p>
<ul>
<li>Non-free licensed software with released source-code.</li>
<li>Software released only as redistributable binary packages.</li>
<li>Patented technology, which may or may not have an (otherwise) open
implementation.</li>
</ul>
<h3><a class="header" href="#multilib" id="multilib">multilib</a></h3>
<p>The <code>multilib</code> repository provides 32-bit packages as a compatibility layer
inside a 64-bit system. It can be enabled by installing the
<code>void-repo-multilib</code> package.</p>
<p>These repositories are only available for <code>x86_64</code> systems running the
<code>glibc</code> C library.</p>
<h3><a class="header" href="#multilibnonfree" id="multilibnonfree">multilib/nonfree</a></h3>
<p>The <code>multilib/nonfree</code> repository provides additional 32-bit packages which
have non-free licenses. It can be enabled by installing the
<code>void-repo-multilib-nonfree</code> package.</p>
<h3><a class="header" href="#debug" id="debug">debug</a></h3>
<p>Void Linux packages come without debugging symbols. If you want to debug
software or look at a core dump you will need the debugging symbols. These
packages are contained in the debug repository. It can be enabled by
installing the <code>void-repo-debug</code> package.</p>
<p>Once enabled, symbols may be obtained for <code>&lt;package&gt;</code> by installing
<code>&lt;package&gt;-dbg</code>.</p>
<h4><a class="header" href="#finding-debug-dependencies" id="finding-debug-dependencies">Finding debug dependencies</a></h4>
<p>The <code>xtools</code> package contains the
<a href="https://man.voidlinux.org/xtools.1">xdbg(1)</a>  utility to retrieve a list of
debug packages, including dependencies, for a package:</p>
<p><code>$ xdbg bash bash-dbg glibc-dbg # xbps-install -S $(xdbg bash) </code></p>
<h1><a class="header" href="#mirrors" id="mirrors">Mirrors</a></h1>
<p>Void Linux maintains mirrors in several geographic regions for you to use. A
fresh install will default to using the master mirror in Europe, but you may
also <a href="xbps/repositories/mirrors/./changing.html">select a different mirror</a> manually.</p>
<h2><a class="header" href="#tier-1-mirrors" id="tier-1-mirrors">Tier 1 mirrors</a></h2>
<p>Tier 1 mirrors are maintained by the Void Linux Infrastructure Team. These
mirrors sync directly from the build-master and will always have the latest
packages available.</p>
<table><thead><tr><th>Repository</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="https://alpha.de.repo.voidlinux.org/">https://alpha.de.repo.voidlinux.org/</a></td><td>EU: Finland</td></tr>
<tr><td><a href="https://mirrors.servercentral.com/voidlinux/">https://mirrors.servercentral.com/voidlinux/</a></td><td>USA: Chicago</td></tr>
<tr><td><a href="https://alpha.us.repo.voidlinux.org/">https://alpha.us.repo.voidlinux.org/</a></td><td>USA: Kansas City</td></tr>
<tr><td><a href="https://mirror.clarkson.edu/voidlinux/">https://mirror.clarkson.edu/voidlinux/</a></td><td>USA: New York</td></tr>
</tbody></table>
<h2><a class="header" href="#tier-2-mirrors" id="tier-2-mirrors">Tier 2 mirrors</a></h2>
<p>Tier 2 mirrors sync from a nearby Tier 1 mirror when possible. These mirrors
are not managed by Void and do not have any guarantees of freshness or
completeness of packages, nor are they required to sync every available
architecture or sub-repository.</p>
<h3><a class="header" href="#globally-available-mirrors" id="globally-available-mirrors">Globally-available mirrors</a></h3>
<table><thead><tr><th>Repository</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="https://mirror.ps.kz/voidlinux/">https://mirror.ps.kz/voidlinux/</a></td><td>Asia: Almaty, KZ</td></tr>
<tr><td><a href="https://mirrors.bfsu.edu.cn/voidlinux/">https://mirrors.bfsu.edu.cn/voidlinux/</a></td><td>Asia: China</td></tr>
<tr><td><a href="https://mirrors.cnnic.cn/voidlinux/">https://mirrors.cnnic.cn/voidlinux/</a></td><td>Asia: China</td></tr>
<tr><td><a href="https://mirrors.tuna.tsinghua.edu.cn/voidlinux/">https://mirrors.tuna.tsinghua.edu.cn/voidlinux/</a></td><td>Asia: China</td></tr>
<tr><td><a href="https://mirror.maakpain.kro.kr/void/">https://mirror.maakpain.kro.kr/void/</a></td><td>Asia: Seoul, SK</td></tr>
<tr><td><a href="https://void.webconverger.org/">https://void.webconverger.org/</a></td><td>Asia: Singapore</td></tr>
<tr><td><a href="https://mirror.aarnet.edu.au/pub/voidlinux/">https://mirror.aarnet.edu.au/pub/voidlinux/</a></td><td>AU: Canberra</td></tr>
<tr><td><a href="https://ftp.swin.edu.au/voidlinux/">https://ftp.swin.edu.au/voidlinux/</a></td><td>AU: Melbourne</td></tr>
<tr><td><a href="https://void.cijber.net/">https://void.cijber.net/</a></td><td>EU: Amsterdam, NL</td></tr>
<tr><td><a href="http://ftp.dk.xemacs.org/voidlinux/">http://ftp.dk.xemacs.org/voidlinux/</a></td><td>EU: Denmark</td></tr>
<tr><td><a href="https://mirrors.dotsrc.org/voidlinux/">https://mirrors.dotsrc.org/voidlinux/</a></td><td>EU: Denmark</td></tr>
<tr><td><a href="https://quantum-mirror.hu/mirrors/pub/voidlinux/">https://quantum-mirror.hu/mirrors/pub/voidlinux/</a></td><td>EU: Hungary</td></tr>
<tr><td><a href="https://mirror.i-novus.ru/mirrors/voidlinux/">https://mirror.i-novus.ru/mirrors/voidlinux/</a></td><td>EU: Ireland</td></tr>
<tr><td><a href="http://ftp.debian.ru/mirrors/voidlinux/">http://ftp.debian.ru/mirrors/voidlinux/</a></td><td>EU: Russia</td></tr>
<tr><td><a href="https://mirror.yandex.ru/mirrors/voidlinux/">https://mirror.yandex.ru/mirrors/voidlinux/</a></td><td>EU: Russia</td></tr>
<tr><td><a href="https://cdimage.debian.org/mirror/voidlinux/">https://cdimage.debian.org/mirror/voidlinux/</a></td><td>EU: Sweden</td></tr>
<tr><td><a href="https://ftp.acc.umu.se/mirror/voidlinux/">https://ftp.acc.umu.se/mirror/voidlinux/</a></td><td>EU: Sweden</td></tr>
<tr><td><a href="https://ftp.gnome.org/mirror/voidlinux/">https://ftp.gnome.org/mirror/voidlinux/</a></td><td>EU: Sweden</td></tr>
<tr><td><a href="https://ftp.lysator.liu.se/pub/voidlinux/">https://ftp.lysator.liu.se/pub/voidlinux/</a></td><td>EU: Sweden</td></tr>
<tr><td><a href="https://ftp.sunet.se/mirror/voidlinux/">https://ftp.sunet.se/mirror/voidlinux/</a></td><td>EU: Sweden</td></tr>
</tbody></table>
<h3><a class="header" href="#region-locked-mirrors" id="region-locked-mirrors">Region-locked mirrors</a></h3>
<table><thead><tr><th>Repository</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="https://mirrors.hushan.tech:44300/voidlinux">https://mirrors.hushan.tech:44300/voidlinux</a></td><td>Asia: China</td></tr>
</tbody></table>
<h2><a class="header" href="#tor-mirrors" id="tor-mirrors">Tor Mirrors</a></h2>
<p>Void Linux is also mirrored on the Tor network. See <a href="xbps/repositories/mirrors/./tor.html">Using Tor
Mirrors</a> for more information.</p>
<h2><a class="header" href="#creating-a-mirror" id="creating-a-mirror">Creating a mirror</a></h2>
<p>If you'd like to set up a mirror, and are confident you can keep it
reasonably up-to-date, follow one of the many guides available for mirroring
with <a href="https://man.voidlinux.org/rsync.1">rsync(1)</a>, then submit a pull
request to <a href="https://github.com/void-linux/void-docs">the void-docs
repository</a> to add your mirror to
the appropriate mirror table on this page.</p>
<p>A full mirror requires around 1TB of storage. It is also possible to mirror
only part of the repositories. Excluding debug packages is one way of
decreasing the load on the Tier 1 mirrors, with low impact on users.</p>
<p>Please keep in mind that we pay bandwidth for all data sent out from the
Tier 1 mirrors. You can respect this by only mirroring if your use case for
your mirror will offset the network throughput consumed by your mirror
syncing.</p>
<h1><a class="header" href="#changing-mirrors" id="changing-mirrors">Changing Mirrors</a></h1>
<p>Each repository has a file defining the URL for the mirror used. For
official repositories, these files are installed by the package manager in
<code>/usr/share/xbps.d</code>, but if duplicate files are found in <code>/etc/xbps.d</code>,
those values are used instead.</p>
<p>To modify mirror URLs cleanly, copy all the repository configuration files
to <code>/etc/xbps.d</code> and change the URLs in each copied repository file.</p>
<pre><code class="language-#mkdir-p/etc/xbps.d#cp/usr/share/xbps.d/*-repository-*.conf">/etc/xbps.d/ # sed -i 's|https://alpha.de.repo.voidlinux.org|&lt;repository&gt;|g'
/etc/xbps.d/*-repository-*.conf ```

After changing the URLs, you must synchronize xbps with the new mirrors:

``` # xbps-install -S ```

You should see the new repository URLs while synchronizing. You can also use
`xbps-query` to verify the repository URLs, but only after they have been
synchronized:

</code></pre>
<p>$ xbps-query -L
9970 https://alpha.de.repo.voidlinux.org/current (RSA signed)
27 https://alpha.de.repo.voidlinux.org/current/multilib/nonfree (RSA signed)
4230 https://alpha.de.repo.voidlinux.org/current/multilib (RSA signed)
47 https://alpha.de.repo.voidlinux.org/current/nonfree (RSA signed)
5368 https://alpha.de.repo.voidlinux.org/current/debug (RSA signed)</p>
<pre><code>
Remember that repositories added afterwards will also need to be changed, or
they will use the default mirror.
</code></pre>
<h1><a class="header" href="#using-tor-mirrors" id="using-tor-mirrors">Using Tor Mirrors</a></h1>
<p>Tor is an anonymizing software that bounces traffic via computers all around
the world. It can provide access to regular sites on the internet or to
hidden sites only available on the network.</p>
<p>The following Void Linux Mirrors are available on the Tor Network:</p>
<table><thead><tr><th>Repository</th><th>Location</th></tr></thead><tbody>
<tr><td><a href="http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/">http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/</a></td><td>EU: Sweden</td></tr>
</tbody></table>
<h2><a class="header" href="#using-xbps-with-tor" id="using-xbps-with-tor">Using XBPS with Tor</a></h2>
<p>XBPS can be made to connect to mirrors using Tor. These mirrors can be
normal mirrors, via exit relays, or, for potentially greater anonymity,
hidden service mirrors on the network.</p>
<p>XBPS respects the <code>SOCKS_PROXY</code> environment variable, which makes it easy to
use via Tor.</p>
<h3><a class="header" href="#installing-tor" id="installing-tor">Installing Tor</a></h3>
<p>Tor is contained in the <code>tor</code> package.</p>
<p>After having installed Tor, you can start it as your own user:</p>
<p><code>$ tor</code></p>
<p>or enable its system service.</p>
<p>By default, Tor will act as a client and open a SOCKS5 proxy on TCP port
9050 on localhost.</p>
<h3><a class="header" href="#making-xbps-connect-via-the-socks-proxy" id="making-xbps-connect-via-the-socks-proxy">Making XBPS connect via the SOCKS proxy</a></h3>
<p>XBPS reads the <code>SOCKS_PROXY</code> environment variable and will use any proxy
specified in it. By simply setting the variable to the address and port of
the proxy opened by the Tor client, all XBPS's connections will go over the
Tor network.</p>
<p>An example upgrading your system over Tor:</p>
<p><code># export SOCKS_PROXY=&quot;socks5://127.0.0.1:9050&quot; # xbps-install -Su</code></p>
<h3><a class="header" href="#using-a-hidden-service-mirror" id="using-a-hidden-service-mirror">Using a hidden service mirror</a></h3>
<p>To use a hidden service mirror, the default mirrors need to be overwritten
with configuration files pointing to <code>.onion</code>-addresses that are used
internally on the Tor network. XBPS allows overriding repository addresses
under <code>/etc/xbps.d</code>.</p>
<p>Copy your repository files from <code>/usr/share/xbps.d</code> to <code>/etc/xbps.d</code> and
replace the addresses with that of an onion service (Lysator's onion used as
an example):</p>
<pre><code class="language-#mkdir-p/etc/xbps.d#cp/usr/share/xbps.d/*-repository-*.conf">/etc/xbps.d/ # sed -i
's|https://alpha.de.repo.voidlinux.org|http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux|g'
/etc/xbps.d/*-repository-*.conf ```

Tor provides layered end-to-end encryption so HTTPS is not necessary.

When installing packages, with `SOCKS_PROXY` set like the earlier example,
XBPS should indicate that it is synchronizing the repositories from the
onion address specified in the override:

``` # xbps-install -S [*] Updating
`http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/current/aarch64/nonfree/aarch64-repodata'
...  aarch64-repodata: 4030B [avg rate: 54KB/s] [*] Updating
`http://lysator7eknrfl47rlyxvgeamrv7ucefgrrlhk7rouv3sna25asetwid.onion/pub/voidlinux/current/aarch64/aarch64-repodata'
...  aarch64-repodata: 1441KB [avg rate: 773KB/s] ```

### Security consideration

It is advisable to set `SOCKS_PROXY` automatically in your environment if
you are using an onion. If the setting is missing, a DNS query for the name
of the hidden service will leak to the configured DNS server.

To automatically set the environment variable, add it to a file in
`/etc/profile.d`:

``` # cat - &lt;&lt;EOF &gt; /etc/profile.d/socksproxy.sh #!/bin/sh export
SOCKS_PROXY=&quot;socks5://127.0.0.1:9050&quot; EOF ```
</code></pre>
<h1><a class="header" href="#restricted-packages-1" id="restricted-packages-1">Restricted Packages</a></h1>
<p>Void offers some packages that are officially maintained, but not
distributed.  These packages are marked as restricted and must be built from
their <a href="https://github.com/void-linux/void-packages">void-packages</a> template
locally.</p>
<p>Packages can be restricted from distribution by either the upstream author
or Void. Void reserves the right to restrict distribution of any package for
effectively any reason, massive size being the most common. Another common
reason is restrictive licensing that does not allow third-party
redistribution of source or binary packages.</p>
<h2><a class="header" href="#building-manually" id="building-manually">Building manually</a></h2>
<p>You can use <code>xbps-src</code> in the
<a href="https://github.com/void-linux/void-packages">void-packages</a> repository to
build the restricted packages from templates. For instructions on building
packages from templates, refer to the
<a href="https://github.com/void-linux/void-packages">void-packages</a> documentation,
and the <a href="https://github.com/void-linux/void-packages#quick-start">&quot;Quick start&quot;
section</a> in
particular .</p>
<p>Remember that the building of restricted packages must be enabled explicitly
by setting <code>XBPS_ALLOW_RESTRICTED=yes</code> in your <code>xbps-src</code> configuration (in
the <code>etc/conf</code> file in the repository.)</p>
<h2><a class="header" href="#automated-building" id="automated-building">Automated building</a></h2>
<p>There is also a tool,
<a href="https://github.com/the-maldridge/xbps-mini-builder">xbps-mini-builder</a>
which automates the process of building a list of packages. The script can
be called periodically and will only rebuild packages if their templates
have changed.</p>
<h1><a class="header" href="#custom-repositories" id="custom-repositories">Custom Repositories</a></h1>
<p>Void supports user-created repositories, both local and remote. This is only
recommended for serving custom packages created personally, or packages from
another trusted source. The Void project does not support <em>any</em> third-party
package repositories - the use of third-party software packages poses very
serious security concerns, and risks serious damage your system.</p>
<h2><a class="header" href="#adding-custom-repositories" id="adding-custom-repositories">Adding custom repositories</a></h2>
<p>To add a custom repository, create a file in <code>/etc/xbps.d</code>, with the
contents:</p>
<p><code>repository=&lt;URL&gt;</code></p>
<p>where <code>&lt;URL&gt;</code> is either a local directory or a URL to a remote repository.</p>
<p>For example, to define a remote repository:</p>
<pre><code class="language-#echo'repository=http://my.domain.com/repo'&gt;">/etc/xbps.d/my-remote-repo.conf ```

Remote repositories need to be [signed](./signing.md).
[xbps-install(1)](https://man.voidlinux.org/xbps-install.1) refuses to
install packages from remote repositories if they are not signed.

To define a local repository:

``` # echo 'repository=/path/to/repo' &gt; /etc/xbps.d/my-local-repo.conf ```
</code></pre>
<h1><a class="header" href="#signing-repositories" id="signing-repositories">Signing Repositories</a></h1>
<p>Remote repositories <strong>must</strong> be signed. Local repositories do not need to be
signed.</p>
<p>The <a href="https://man.voidlinux.org/xbps-rindex.1">xbps-rindex(1)</a> tool is used
to sign repositories.</p>
<p>The private key for signing packages needs to be a PEM-encoded RSA key. The
key can be generated with either
<a href="https://man.voidlinux.org/ssh-keygen.1">ssh-keygen(1)</a> or
<a href="https://man.voidlinux.org/openssl.1">openssl(1)</a>:</p>
<p><code>$ ssh-keygen -t rsa -m PEM -f private.pem</code></p>
<p><code>$ openssl genrsa -out private.pem</code></p>
<p>Once the key is generated, the public part of the private key has to be
added to the repository metadata. This step is required only once.</p>
<pre><code class="language-$xbps-rindex--privkeyprivate.pem--sign--signedby&quot;I'mGroot&quot;">/path/to/repository/dir ```

Then sign one or more packages with the following command:

``` $ xbps-rindex --privkey private.pem --sign-pkg
/path/to/repository/dir/*.xbps ```

Note that future packages will not be automatically signed.
</code></pre>
<h1><a class="header" href="#troubleshooting-xbps" id="troubleshooting-xbps">Troubleshooting XBPS</a></h1>
<p>Sometimes the package manager gets in a weird spot and can't fix itself
without help. This section documents important fixes and things that can go
wrong when working with XBPS.</p>
<h2><a class="header" href="#section-contents-5" id="section-contents-5">Section Contents</a></h2>
<ul>
<li><a href="xbps/troubleshooting/./common-issues.html">Common Issues</a>  - <a href="xbps/troubleshooting/./static.html">Static XBPS</a></li>
</ul>
<h1><a class="header" href="#common-issues" id="common-issues">Common Issues</a></h1>
<h2><a class="header" href="#verifying-rsa-keys" id="verifying-rsa-keys">Verifying RSA keys</a></h2>
<p>If you are installing Void for the first time or the Void RSA key has
changed, <a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a> might
report:</p>
<p><code>&lt;repository&gt; repository has been RSA signed by &lt;rsa_fingerprint&gt;</code></p>
<p>To verify the signature, ensure the <code>&lt;rsa_fingerprint&gt;</code> matches one of the
fingerprints in both
<a href="https://github.com/void-linux/void-packages/tree/master/common/repo-keys">void-packages</a>
and
<a href="https://github.com/void-linux/void-mklive/tree/master/keys">void-mklive</a>.</p>
<h2><a class="header" href="#errors-while-updating-or-installing-packages" id="errors-while-updating-or-installing-packages">Errors while updating or installing packages</a></h2>
<p>If there are any errors while updating or installing a new package, make
sure that you are using the latest version of the remote repository
index. Running <a href="https://man.voidlinux.org/xbps-install.1">xbps-install(1)</a>
with the <code>-S</code> option will guarantee that.</p>
<h3><a class="header" href="#operation-not-permitted" id="operation-not-permitted">&quot;Operation not permitted&quot;</a></h3>
<p>An &quot;Operation not permitted&quot; error, such as:</p>
<pre><code class="language-ERROR:[reposync]failedtofetchfile">https://alpha.de.repo.voidlinux.org/current/nonfree/x86_64-repodata':
Operation not permitted ```

can be caused by your system's date and/or time being incorrect. Ensure your
[date and time](../../config/date-time.md) are correct.

### &quot;Not Found&quot;

A &quot;Not Found&quot; error, such as:

``` ERROR: [reposync] failed to fetch file
`https://alpha.de.repo.voidlinux.org/current/musl/x86_64-repodata': Not
Found ```

usually means your XBPS configuration is pointing to the wrong repositories
for your system. Confirm that your
[xbps.d(5)](https://man.voidlinux.org/xbps.d.5)  files refer to [the correct
repositories](../repositories/index.md).

### shlib errors

An &quot;unresolvable shlib&quot; error, such as:

``` libllvm8-8.0.1_2: broken, unresolvable shlib `libffi.so.6' ```

is probably due to orphan packages, already removed from the Void repos,
still being installed on your system. This can be solved by running
[xbps-remove(1)](https://man.voidlinux.org/xbps-remove.1) with the `-o`
option, which removes orphan packages.

If you get an error message saying:

``` Transaction aborted due to unresolved shlibs ```

the repositories are in the staging state, which can happen due to large
builds.  The solution is to wait for the builds to finish. You can view the
builds' progress in the [Buildbot's Waterfall
Display](https://build.voidlinux.org/waterfall).

### repodata errors

In March 2020, the compression format used for the repository data
(repodata)  was changed from gzip to zstd. If XBPS wasn't updated to version
`0.54` (released June 2019) or newer, it is not possible to update the
system with it.  Unfortunately, there isn't an error message for this case,
but it can be detected by running `xbps-install` with the `-Sd` flags. The
debug message for this error is shown below.

``` [DEBUG] [repo]
`//var/db/xbps/https___alpha_de_repo_voidlinux_org_current/x86_64-repodata'
failed to open repodata archive Invalid or incomplete multibyte or wide
character ```

In this situation, it is necessary to follow the steps in
[xbps-static](./static.md).

## Broken systems

If your system is for some reason broken and can't perform updates or
package installations, using a [statically linked version of
xbps](./static.md) to update and install packages can help you avoid
reinstalling the whole system.
</code></pre>
<h1><a class="header" href="#static-xbps" id="static-xbps">Static XBPS</a></h1>
<p>In rare cases, it is possible to break the system sufficiently that XBPS can
no longer function. This usually happens while trying to do unsupported
things with libc, but can also happen when an update contains a corrupt
glibc archive or otherwise fails to unpack and configure fully.</p>
<p>Another issue that can present itself is in systems with a XBPS version
before <code>0.54</code> (released June 2019). These systems will be impossible to
update from the official repositories using the regular update procedure,
due a change in the compression format used for repository data, which was
made in March 2020.</p>
<p>In these cases it is possible to recover your system with a separate,
statically compiled copy of XBPS.</p>
<h2><a class="header" href="#obtaining-static-xbps" id="obtaining-static-xbps">Obtaining static XBPS</a></h2>
<p>Statically compiled versions of XBPS are available in all mirrors in the
static/ directory. The link below points to the static copies on the primary
mirror in Germany:</p>
<p><a href="https://alpha.de.repo.voidlinux.org/static">https://alpha.de.repo.voidlinux.org/static</a></p>
<p>Download and unpack the latest version, or the version that matches the
broken copy on your system (with a preference for the latest copy).</p>
<h2><a class="header" href="#using-static-xbps" id="using-static-xbps">Using static XBPS</a></h2>
<p>The tools in the static set are identical to the normal ones found on most
systems. The only distinction is that these tools are statically linked to
the musl C library, and should work on systems where nothing else does. In
systems where the platform can no longer boot, it is recommended to chroot
in with Void installation media and use the static tools from there, as it
is unlikely that even a shell will work correctly on the target system. When
using static XBPS with glibc installation, environmental variable
<code>XBPS_ARCH</code> need to be set.</p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<p>There's more to running a distribution than just writing code.</p>
<p>To contribute to the Void packages repository, start by reading the
<a href="https://github.com/void-linux/void-packages/blob/master/CONTRIBUTING.md">CONTRIBUTING</a>
document in the void-packages GitHub repository.</p>
<p>To contribute to this Handbook, read
<a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a>
in the void-docs repository.</p>
<p>If you have any questions, feel free to ask them via IRC in #voidlinux on
irc.freenode.net, or in <a href="https://reddit.com/r/voidlinux">the voidlinux
subreddit</a>.</p>
<h2><a class="header" href="#usage-statistics" id="usage-statistics">Usage Statistics</a></h2>
<p>If you would like to contribute usage reports, the
<a href="https://github.com/the-maldridge/popcorn">PopCorn</a> program reports
installation statistics back to the Void project. These statistics are
purely opt-in - PopCorn is <em>not</em> installed or enabled by default on any Void
systems.</p>
<p><em>PopCorn</em> only reports which packages are installed, their version, and the host
CPU architecture (the output of <code>xuname</code>). This does not report which services
are enabled, or any other personal information. Individual systems are tracked
persistently by a random (client-generated) UUID, to ensure that each system is
only counted once in each 24-hour sampling period.</p>
<p>The data collected by <em>PopCorn</em> is available to view at
<a href="http://popcorn.voidlinux.org">http://popcorn.voidlinux.org</a></p>
<h3><a class="header" href="#setting-up-popcorn" id="setting-up-popcorn">Setting up PopCorn</a></h3>
<p>First, install the <code>PopCorn</code> package. Then, enable the <code>popcorn</code> service,
which will attempt to report statistics once per day.</p>
<h1><a class="header" href="#contributing-to-void-docs" id="contributing-to-void-docs">Contributing To void-docs</a></h1>
<p>The sources for this handbook are hosted in the
<a href="https://github.com/void-linux/void-docs">void-docs</a> repository on
<a href="https://github.com">GitHub</a>. If you would like to make a contribution,
please read about <a href="contributing/void-docs/../../about/about-this-handbook.html">the purpose of the
Handbook</a>, follow our <a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md#style-guide">style
guide</a>
and <a href="https://github.com/void-linux/void-docs/blob/master/CONTRIBUTING.md#submitting-changes">submit a pull
request</a>.</p>

				</main>

				<nav id="nav-wide-wrapper" aria-label="Page navigation">
					

					
				</nav>
			</div>
		</div>

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="book.js" type="text/javascript" charset="utf-8"></script>
    </body>
</html>
